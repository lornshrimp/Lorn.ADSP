# 统一配置化和依赖注入架构设计

# 统一配置化和依赖注入架构设计

## 设计目标

为 Lorn.ADSP 广告平台设计一个统一的配置管理和依赖注入基础设施，解决当前系统中配置和组件注册分散、缺乏标准的问题。

**核心目标**：
- **统一配置管理**：提供标准化的配置加载、验证、热重载机制
- **统一组件注册**：提供标准化的组件发现、注册、生命周期管理
- **零配置扩展**：新增配置项和组件时无需修改基础设施代码
- **开箱即用**：基于约定和元数据，自动完成配置绑定和组件注册

## 基础设施项目结构

### 项目组织架构

```text
Infrastructure/
├── Lorn.ADSP.Infrastructure.Configuration/       # 配置管理基础设施
│   ├── Providers/                               # 配置提供者实现
│   │   ├── JsonConfigurationProvider.cs        # JSON文件配置
│   │   ├── EnvironmentConfigurationProvider.cs # 环境变量配置
│   │   ├── DatabaseConfigurationProvider.cs    # 数据库配置
│   │   └── CompositeConfigurationProvider.cs   # 组合配置源
│   ├── Validation/                              # 配置验证器
│   │   ├── ConfigurationValidator.cs           # 核心验证器
│   │   ├── ValidationRuleEngine.cs             # 验证规则引擎
│   │   └── ValidationResult.cs                 # 验证结果模型
│   ├── Binding/                                # 配置绑定器
│   │   ├── TypedConfigurationBinder.cs         # 强类型绑定
│   │   ├── ConventionConfigurationBinder.cs    # 约定绑定
│   │   └── ConfigurationChangeTracker.cs       # 变更跟踪
│   ├── Extensions/                              # 扩展方法
│   │   └── ConfigurationBuilderExtensions.cs   # 配置构建器扩展
│   └── Models/                                  # 配置模型
│       ├── ConfigurationSchema.cs              # 配置架构定义
│       ├── ConfigurationMetadata.cs            # 配置元数据
│       └── ConfigurationOptions.cs             # 基础配置选项
├── Lorn.ADSP.Infrastructure.DependencyInjection/ # 依赖注入基础设施
│   ├── Discovery/                               # 组件发现器
│   │   ├── AssemblyComponentScanner.cs         # 程序集扫描器
│   │   ├── ConventionComponentDiscovery.cs     # 约定发现器
│   │   └── MetadataComponentFilter.cs          # 元数据过滤器
│   ├── Registration/                            # 组件注册器
│   │   ├── ComponentRegistrationBuilder.cs     # 注册构建器
│   │   ├── BatchComponentRegistrar.cs          # 批量注册器
│   │   └── LifecycleManager.cs                 # 生命周期管理
│   ├── Attributes/                              # 特性标记
│   │   ├── ComponentAttribute.cs               # 组件标记
│   │   ├── ConfigurationBindingAttribute.cs    # 配置绑定标记
│   │   └── DependencyAttribute.cs              # 依赖声明标记
│   ├── Extensions/                              # 扩展方法
│   │   └── ComponentRegistrationExtensions.cs  # 组件注册扩展
│   └── Models/                                  # 组件模型
│       ├── ComponentDescriptor.cs              # 组件描述符
│       ├── ComponentMetadata.cs                # 组件元数据
│       └── RegistrationOptions.cs              # 注册选项
├── Lorn.ADSP.Infrastructure.Composition/        # 基础设施组合层
│   ├── Extensions/                              # 统一基础设施扩展
│   │   └── ServiceCollectionExtensions.cs      # 基础设施注册扩展（唯一对外接口）
│   ├── Bootstrapper/                            # 启动器
│   │   ├── InfrastructureBootstrapper.cs       # 基础设施启动器
│   │   └── ComponentBootstrapper.cs            # 组件启动器
│   └── Configuration/                           # 组合配置
│       ├── InfrastructureSettings.cs           # 基础设施设置
│       └── BootstrapOptions.cs                 # 启动选项
└── Lorn.ADSP.Infrastructure.Common/             # 公共基础设施
    ├── Abstractions/                            # 基础抽象
    │   ├── IConfigurable.cs                    # 可配置接口
    │   ├── IComponent.cs                       # 组件基础接口
    │   └── IHealthCheckable.cs                 # 健康检查接口
    ├── Base/                                    # 基础类
    │   ├── ConfigurableComponentBase.cs        # 可配置组件基类
    │   ├── ComponentBase.cs                    # 组件基类
    │   └── HealthCheckableComponentBase.cs     # 健康检查组件基类
    └── Models/                                  # 公共模型
        ├── ComponentDescriptor.cs              # 组件描述符
        ├── ComponentMetadata.cs                # 组件元数据
        └── InfrastructureOptions.cs            # 基础设施配置选项
    ├── Conventions/                             # 约定规范
    │   ├── NamingConventions.cs                # 命名约定
    │   ├── ConfigurationConventions.cs         # 配置约定
    │   └── ComponentConventions.cs             # 组件约定
    └── Extensions/                              # 通用扩展
        ├── TypeExtensions.cs                   # 类型扩展
        ├── ReflectionExtensions.cs             # 反射扩展
        └── ValidationExtensions.cs             # 验证扩展
```

### 各项目功能职责

#### Lorn.ADSP.Infrastructure.Configuration

**核心职责**：提供统一的配置管理基础设施

**主要功能**：
- **多源配置支持**：JSON文件、环境变量、数据库、命令行参数
- **强类型绑定**：自动将配置映射到强类型对象
- **配置验证**：支持数据注解和自定义验证规则
- **热重载机制**：配置文件变更时自动重新加载
- **配置合并**：支持多环境配置的层次化合并
- **配置加密**：敏感配置的加密存储和解密

#### Lorn.ADSP.Infrastructure.DependencyInjection

**核心职责**：提供统一的组件注册和依赖注入基础设施

**主要功能**：
- **组件自动发现**：基于约定和特性自动扫描组件
- **批量注册**：支持程序集级别的批量组件注册
- **生命周期管理**：自动推断和管理组件生命周期
- **配置绑定集成**：组件注册时自动绑定配置
- **条件注册**：基于环境或配置的条件注册
- **装饰器支持**：非侵入式的组件功能增强

#### Lorn.ADSP.Infrastructure.Common

**核心职责**：提供公共的基础设施和约定规范

**主要功能**：
- **基础接口定义**：定义组件的基础能力接口
- **基础类实现**：提供常用的基础类实现
- **约定规范**：定义命名、配置、组件的约定规范
- **通用扩展方法**：提供常用的扩展方法和工具类

## 核心设计理念

### 1. 配置管理是基础设施，不是业务扩展点

**配置管理的本质**：
- 配置管理应该是一个**完整的、开箱即用的基础设施**
- 当增加新的配置项时，只需要**添加配置内容**，无需修改配置管理代码
- 通过**约定和元数据**实现零配置的自动绑定

**错误的设计**：把配置管理设计成接口，每次新增配置都要写新的实现
**正确的设计**：配置管理是具体实现，通过约定自动处理各种配置

### 2. 依赖注入是组件组装工具，不是业务逻辑

**依赖注入的本质**：
- 依赖注入应该是一个**智能的组件组装器**
- 当增加新的组件时，只需要**标记组件特性**，无需修改注册代码
- 通过**程序集扫描和约定**实现自动发现和注册

**错误的设计**：把每种业务组件都设计成需要专门的注册器
**正确的设计**：一个通用的注册器，通过元数据和约定处理所有类型的组件

### 3. 基于约定的零配置设计

约定规范是整个基础设施的核心，所有业务组件开发者必须遵循这些约定才能享受零配置的便利。

## 基础设施组合层设计

为了避免循环引用问题，我们创建一个专门的**组合层（Composition Layer）**，它位于所有基础设施项目的最上层，负责组装和协调各个基础设施组件。

### 依赖关系设计

```
应用程序层 (Application)
    ↓ 只依赖
基础设施组合层 (Infrastructure.Composition) 
    ↓ 依赖
┌─ 配置基础设施 (Infrastructure.Configuration)
├─ 依赖注入基础设施 (Infrastructure.DependencyInjection)  
└─ 公共基础设施 (Infrastructure.Common)
    ↑ 被所有基础设施项目依赖（提供基础抽象）
```

### 统一的基础设施扩展入口

```csharp
// Lorn.ADSP.Infrastructure.Composition/Extensions/ServiceCollectionExtensions.cs
// 这是整个基础设施唯一的对外接口，位于组合层避免循环引用
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// 注册广告系统基础设施
    /// 这是外部应用程序唯一需要调用的方法
    /// </summary>
    /// <param name="services">服务集合</param>
    /// <param name="configuration">配置对象</param>
    /// <returns>服务集合</returns>
    public static IServiceCollection AddAdSystemInfrastructure(
        this IServiceCollection services, 
        IConfiguration configuration)
    {
        // 使用基础设施启动器来组装所有组件
        var bootstrapper = new InfrastructureBootstrapper(services, configuration);
        return bootstrapper.Bootstrap();
    }
    
    /// <summary>
    /// 为健康检查系统添加组件健康检查支持
    /// </summary>
    /// <param name="builder">健康检查构建器</param>
    /// <returns>健康检查构建器</returns>
    public static IHealthChecksBuilder AddComponentHealthChecks(this IHealthChecksBuilder builder)
    {
        // 自动扫描所有实现 IHealthCheckable 的组件并添加健康检查
        var healthCheckableTypes = AssemblyScanner.FindTypes(type => 
            typeof(IHealthCheckable).IsAssignableFrom(type) && 
            type.IsClass && 
            !type.IsAbstract);
            
        foreach (var type in healthCheckableTypes)
        {
            builder.AddTypeActivatedCheck(type.Name, type);
        }
        
        return builder;
    }
}
```

### 基础设施启动器

```csharp
// Lorn.ADSP.Infrastructure.Composition/Bootstrapper/InfrastructureBootstrapper.cs
// 负责协调各个基础设施组件的启动
public class InfrastructureBootstrapper
{
    private readonly IServiceCollection _services;
    private readonly IConfiguration _configuration;
    
    public InfrastructureBootstrapper(IServiceCollection services, IConfiguration configuration)
    {
        _services = services;
        _configuration = configuration;
    }
    
    public IServiceCollection Bootstrap()
    {
        // 1. 配置管理 - 自动注册所有配置类型
        BootstrapConfiguration();
        
        // 2. 组件注册 - 基于约定规则自动注册
        BootstrapComponents();
        
        // 3. 健康检查（自动为所有组件添加）
        BootstrapHealthChecks();
        
        return _services;
    }
    
    private void BootstrapConfiguration()
    {
        // 使用配置基础设施项目中的管理器
        var configManager = new AdSystemConfigurationManager(_configuration, _services);
        configManager.RegisterAllOptions();
    }
    
    private void BootstrapComponents()
    {
        // 使用依赖注入基础设施项目中的管理器
        var configManager = new AdSystemConfigurationManager(_configuration, _services);
        var componentManager = new ComponentRegistrationManager(_services, configManager);
        componentManager.RegisterAllComponents();
    }
    
    private void BootstrapHealthChecks()
    {
        _services.AddHealthChecks().AddComponentHealthChecks();
    }
}
```

## 具体实现设计

### 配置管理实现

#### 核心配置管理器

```csharp
// 统一的配置管理器 - 这是具体实现，不是接口
public class AdSystemConfigurationManager
{
    private readonly IConfiguration _configuration;
    private readonly IServiceCollection _services;
    private readonly ConfigurationValidationManager _validationManager;
    private readonly HashSet<Type> _registeredOptionsTypes = new();
    private readonly Dictionary<string, Type> _namedOptionsRegistry = new();
    
    public AdSystemConfigurationManager(IConfiguration configuration, IServiceCollection services)
    {
        _configuration = configuration;
        _services = services;
        _validationManager = new ConfigurationValidationManager(services);
    }
    
    // 自动注册所有 *Options 类型的配置
    public void RegisterAllOptions()
    {
        var optionsTypes = AssemblyScanner.FindTypes(type => 
            type.Name.EndsWith("Options") && 
            type.IsClass && 
            !type.IsAbstract);
            
        foreach (var optionsType in optionsTypes)
        {
            RegisterConventionOptions(optionsType);
        }
    }
    
    // 为组件注册特定配置（支持 ConfigurationBinding 特性）
    public void RegisterComponentOptions(Type componentType, Type optionsType, string configurationPath)
    {
        var componentName = componentType.Name;
        var registryKey = $"{optionsType.FullName}:{componentName}";
        
        // 避免重复注册相同的命名配置
        if (_namedOptionsRegistry.ContainsKey(registryKey))
        {
            return;
        }
        
        // 查找支持命名选项的 Configure 方法
        var configureMethod = typeof(OptionsConfigurationServiceCollectionExtensions)
            .GetMethods()
            .FirstOrDefault(m => 
                m.Name == "Configure" && 
                m.IsGenericMethodDefinition &&
                m.GetParameters().Length == 3 &&
                m.GetParameters()[1].ParameterType == typeof(string) &&
                m.GetParameters()[2].ParameterType == typeof(IConfiguration));
        
        if (configureMethod != null)
        {
            var genericMethod = configureMethod.MakeGenericMethod(optionsType);
            var configSection = _configuration.GetSection(configurationPath);
            
            // 使用组件名作为命名选项的名称，支持多组件共享配置选项类型
            genericMethod.Invoke(null, new object[] 
            { 
                _services, 
                componentName, // 组件名作为命名选项名称
                configSection
            });
            
            // 记录已注册的命名配置
            _namedOptionsRegistry[registryKey] = optionsType;
        }
        
        // 使用统一的验证管理器
        _validationManager.RegisterValidatorsForOptionsType(optionsType);
    }
    
    // 根据约定自动绑定配置（仅处理传统的无命名配置）
    private void RegisterConventionOptions(Type optionsType)
    {
        // 避免重复注册
        if (_registeredOptionsTypes.Contains(optionsType))
        {
            return;
        }
        
        // 约定：AdEngineOptions -> "AdEngine" 配置节
        var sectionName = optionsType.Name.Replace("Options", "");
        
        // 使用 Microsoft.Extensions.Options 进行强类型绑定
        var configureMethod = typeof(OptionsConfigurationServiceCollectionExtensions)
            .GetMethod("Configure", new[] { typeof(IServiceCollection), typeof(IConfiguration) })
            .MakeGenericMethod(optionsType);
            
        configureMethod.Invoke(null, new object[] { 
            _services, 
            _configuration.GetSection(sectionName) 
        });
        
        // 记录已注册的配置类型
        _registeredOptionsTypes.Add(optionsType);
        
        // 使用统一的验证管理器
        _validationManager.RegisterValidatorsForOptionsType(optionsType);
    }
}
```

#### 配置验证器

```csharp
// 统一的配置验证器 - 具体实现
public class ConfigurationValidationManager
{
    private readonly IServiceCollection _services;
    private readonly HashSet<Type> _registeredValidators = new();
    
    public ConfigurationValidationManager(IServiceCollection services)
    {
        _services = services;
    }
    
    // 自动扫描和注册所有验证器
    public void RegisterAllValidators()
    {
        var validatorTypes = AssemblyScanner.FindTypes(type => 
            type.IsClass && 
            !type.IsAbstract &&
            type.GetInterfaces().Any(i => 
                i.IsGenericType && 
                i.GetGenericTypeDefinition() == typeof(IValidateOptions<>)));
                
        foreach (var validatorType in validatorTypes)
        {
            RegisterValidatorType(validatorType);
        }
    }
    
    // 为特定配置类型注册验证器
    public void RegisterValidatorsForOptionsType(Type optionsType)
    {
        var validatorTypes = AssemblyScanner.FindTypes(type => 
            type.IsClass && 
            !type.IsAbstract &&
            type.GetInterfaces().Any(i => 
                i.IsGenericType && 
                i.GetGenericTypeDefinition() == typeof(IValidateOptions<>) &&
                i.GetGenericArguments()[0] == optionsType));
                
        foreach (var validatorType in validatorTypes)
        {
            RegisterValidatorType(validatorType);
        }
    }
    
    // 核心验证器注册逻辑 - 避免重复代码
    private void RegisterValidatorType(Type validatorType)
    {
        if (_registeredValidators.Contains(validatorType))
        {
            return;
        }
        
        var validateInterface = validatorType.GetInterfaces()
            .FirstOrDefault(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IValidateOptions<>));
            
        if (validateInterface != null)
        {
            var optionsType = validateInterface.GetGenericArguments()[0];
            var serviceType = typeof(IValidateOptions<>).MakeGenericType(optionsType);
            
            _services.AddSingleton(serviceType, validatorType);
            _registeredValidators.Add(validatorType);
        }
    }
}
```

### 约定规则管理

```csharp
// 组件约定规则定义 - 基于字符串约定，避免对业务层的强类型依赖
public class ComponentConventionRule
{
    public string Suffix { get; set; }
    public ServiceLifetime Lifetime { get; set; }
    public string[] RequiredInterfaceNames { get; set; } = Array.Empty<string>(); // 使用接口名称字符串
    public string ConfigurationPathTemplate { get; set; } // 如 "Strategies:{0}"
    public string Description { get; set; }
    public bool RequireSpecificInterface { get; set; } = false; // 是否要求特定接口
}

// 组件约定规则管理器 - 完全基于字符串约定，避免业务依赖
public static class ComponentConventions
{
    private static readonly List<ComponentConventionRule> _conventionRules = new()
    {
        new ComponentConventionRule
        {
            Suffix = "Strategy",
            Lifetime = ServiceLifetime.Transient,
            RequiredInterfaceNames = new[] { "IAdProcessingStrategy" }, // 使用接口名称字符串
            ConfigurationPathTemplate = "Strategies:{0}",
            Description = "广告处理策略组件",
            RequireSpecificInterface = true
        },
        new ComponentConventionRule
        {
            Suffix = "Service", 
            Lifetime = ServiceLifetime.Singleton,
            RequiredInterfaceNames = Array.Empty<string>(), // 不要求特定接口
            ConfigurationPathTemplate = "Services:{0}",
            Description = "业务服务组件",
            RequireSpecificInterface = false
        },
        new ComponentConventionRule
        {
            Suffix = "Manager",
            Lifetime = ServiceLifetime.Singleton,
            RequiredInterfaceNames = Array.Empty<string>(),
            ConfigurationPathTemplate = "Managers:{0}",
            Description = "管理器组件",
            RequireSpecificInterface = false
        },
        new ComponentConventionRule
        {
            Suffix = "Provider",
            Lifetime = ServiceLifetime.Singleton,
            RequiredInterfaceNames = new[] { "IDataAccessProvider", "IProvider" }, // 支持多个可能的接口名
            ConfigurationPathTemplate = "Providers:{0}",
            Description = "数据提供者组件",
            RequireSpecificInterface = false // 灵活匹配
        },
        new ComponentConventionRule
        {
            Suffix = "CallbackProvider",
            Lifetime = ServiceLifetime.Singleton,
            RequiredInterfaceNames = new[] { "ICallbackProvider" },
            ConfigurationPathTemplate = "CallbackProviders:{0}",
            Description = "回调提供者组件",
            RequireSpecificInterface = true
        },
        new ComponentConventionRule
        {
            Suffix = "Matcher",
            Lifetime = ServiceLifetime.Scoped,
            RequiredInterfaceNames = new[] { "ITargetingMatcher", "IMatcher" },
            ConfigurationPathTemplate = "Matchers:{0}",
            Description = "定向匹配器组件",
            RequireSpecificInterface = false
        },
        new ComponentConventionRule
        {
            Suffix = "Calculator",
            Lifetime = ServiceLifetime.Scoped,
            RequiredInterfaceNames = new[] { "ICalculator" },
            ConfigurationPathTemplate = "Calculators:{0}",
            Description = "计算器组件",
            RequireSpecificInterface = false
        },
        new ComponentConventionRule
        {
            Suffix = "Processor",
            Lifetime = ServiceLifetime.Scoped,
            RequiredInterfaceNames = new[] { "IProcessor" },
            ConfigurationPathTemplate = "Processors:{0}",
            Description = "处理器组件",
            RequireSpecificInterface = false
        }
    };
    
    public static IReadOnlyList<ComponentConventionRule> GetAllRules() => _conventionRules.AsReadOnly();
    
    public static ComponentConventionRule FindRuleByType(Type type)
    {
        // 优先基于命名约定匹配
        var rule = _conventionRules.FirstOrDefault(r => type.Name.EndsWith(r.Suffix));
        if (rule == null) return null;
        
        // 如果要求特定接口，进行接口验证
        if (rule.RequireSpecificInterface && rule.RequiredInterfaceNames.Length > 0)
        {
            var implementedInterfaceNames = type.GetInterfaces().Select(i => i.Name).ToArray();
            var hasRequiredInterface = rule.RequiredInterfaceNames.Any(required => 
                implementedInterfaceNames.Contains(required));
                
            if (!hasRequiredInterface)
            {
                return null; // 不满足接口要求
            }
        }
        
        return rule;
    }
    
    public static ServiceLifetime GetLifetimeByType(Type type)
    {
        var rule = FindRuleByType(type);
        return rule?.Lifetime ?? ServiceLifetime.Transient;
    }
    
    public static string GetConfigurationPath(Type type)
    {
        var rule = FindRuleByType(type);
        if (rule?.ConfigurationPathTemplate == null) return null;
        
        // 提取组件名称：如 UserInterestRecallStrategy -> UserInterestRecall
        var componentName = type.Name;
        if (componentName.EndsWith(rule.Suffix))
        {
            componentName = componentName.Substring(0, componentName.Length - rule.Suffix.Length);
        }
        
        return string.Format(rule.ConfigurationPathTemplate, componentName);
    }
    
    // 支持运行时添加新的约定规则（可扩展性）
    public static void AddConventionRule(ComponentConventionRule rule)
    {
        if (rule == null) throw new ArgumentNullException(nameof(rule));
        if (string.IsNullOrEmpty(rule.Suffix)) throw new ArgumentException("Suffix cannot be null or empty");
        
        // 检查是否已存在相同后缀的规则
        if (_conventionRules.Any(r => r.Suffix == rule.Suffix))
        {
            throw new InvalidOperationException($"Convention rule with suffix '{rule.Suffix}' already exists");
        }
        
        _conventionRules.Add(rule);
    }
    
    // 检查类型是否符合组件约定
    public static bool IsComponent(Type type)
    {
        if (type == null || !type.IsClass || type.IsAbstract || type.IsGenericTypeDefinition)
            return false;
            
        // 1. 检查是否有明确的组件标记
        if (type.GetCustomAttribute<ComponentAttribute>() != null)
            return true;
            
        // 2. 检查是否符合约定规则
        return FindRuleByType(type) != null;
    }
}
```

### 依赖注入实现

#### 智能组件注册器

```csharp
// 智能组件注册器 - 基于约定规则系统的实现
public class ComponentRegistrationManager
{
    private readonly IServiceCollection _services;
    private readonly AdSystemConfigurationManager _configManager;
    
    public ComponentRegistrationManager(IServiceCollection services, AdSystemConfigurationManager configManager)
    {
        _services = services;
        _configManager = configManager;
    }
    
    // 扫描并注册所有组件
    public void RegisterAllComponents()
    {
        var allTypes = AssemblyScanner.GetAllTypes();
        
        foreach (var type in allTypes)
        {
            // 查找匹配的约定规则
            var rule = ComponentConventions.FindRuleByType(type);
            if (rule != null)
            {
                RegisterComponent(type, rule);
            }
        }
    }
    
    // 注册单个组件
    private void RegisterComponent(Type implementationType, ComponentConventionRule rule)
    {
        // 确定服务类型
        var serviceType = DetermineServiceType(implementationType, rule);
        
        // 注册到 DI 容器
        _services.Add(new ServiceDescriptor(serviceType, implementationType, rule.Lifetime));
        
        // 处理配置绑定
        ProcessConfigurationBinding(implementationType, rule);
    }
    
    // 处理配置绑定 - 同时支持约定和特性两种方式
    private void ProcessConfigurationBinding(Type componentType, ComponentConventionRule rule)
    {
        // 方案一：检查是否有 ConfigurationBinding 特性
        var bindingAttribute = componentType.GetCustomAttribute<ConfigurationBindingAttribute>();
        if (bindingAttribute != null)
        {
            var optionsType = bindingAttribute.OptionsType;
            var configurationPath = bindingAttribute.ConfigurationPath;
            
            // 使用 ConfigurationBinding 特性指定的配置
            _configManager.RegisterComponentOptions(componentType, optionsType, configurationPath);
            return;
        }
        
        // 方案二：使用约定规则
        var configurationPath = ComponentConventions.GetConfigurationPath(componentType);
        if (!string.IsNullOrEmpty(configurationPath))
        {
            // 查找对应的 Options 类型
            var optionsTypeName = $"{componentType.Name}Options";
            var optionsType = componentType.Assembly.GetTypes()
                .FirstOrDefault(t => t.Name == optionsTypeName);
                
            if (optionsType != null)
            {
                _configManager.RegisterComponentOptions(componentType, optionsType, configurationPath);
            }
        }
    }
    
    // 确定服务类型（接口或基类）
    private Type DetermineServiceType(Type implementationType, ComponentConventionRule rule)
    {
        // 优先使用接口
        var interfaceName = $"I{implementationType.Name}";
        var interfaceType = implementationType.GetInterfaces()
            .FirstOrDefault(i => i.Name == interfaceName);
            
        if (interfaceType != null)
        {
            return interfaceType;
        }
        
        // 如果没有对应接口，使用实现类型本身
        return implementationType;
    }
}
```

### 使用示例

#### 应用程序配置

```csharp
// Program.cs - 使用者只需要调用一个方法
public class Program
{
    public static void Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices((context, services) =>
            {
                // 一键配置整个广告系统 - 现在通过组合层避免循环引用
                // 引用: Lorn.ADSP.Infrastructure.Composition
                services.AddAdSystemInfrastructure(context.Configuration);
            })
            .Build();
            
        host.Run();
    }
}
```

**项目引用说明**：
- 应用程序项目只需要引用 `Lorn.ADSP.Infrastructure.Composition`
- 组合层内部处理所有基础设施组件的协调和组装
- 避免了应用程序直接依赖多个基础设施项目的复杂性

#### 业务组件实现示例

```csharp
// 广告策略实现 - 开发者只需要实现业务逻辑，无需关心注册
[Component] // 可选，根据命名约定也会自动发现
[ConfigurationBinding("Strategies:UserInterestRecall")] // 可选，根据约定也会自动推断
public class UserInterestRecallStrategy : IAdProcessingStrategy
{
    private readonly UserInterestRecallOptions _options;
    
    // 配置会自动注入
    public UserInterestRecallStrategy(IOptions<UserInterestRecallOptions> options)
    {
        _options = options.Value;
    }
    
    // 实现业务逻辑即可
    public async Task<ProcessingResult> ProcessAsync(AdRequest request, ProcessingContext context)
    {
        // 业务逻辑实现...
    }
}

// 配置选项 - 会自动绑定到 "Strategies:UserInterestRecall" 配置节
public class UserInterestRecallOptions
{
    public int MaxCandidates { get; set; } = 100;
    public TimeSpan CacheExpiry { get; set; } = TimeSpan.FromMinutes(30);
    public bool EnableDebugLogging { get; set; } = false;
}

// 配置验证器 - 会自动发现并注册
public class UserInterestRecallOptionsValidator : IValidateOptions<UserInterestRecallOptions>
{
    public ValidateOptionsResult Validate(string name, UserInterestRecallOptions options)
    {
        if (options.MaxCandidates <= 0)
            return ValidateOptionsResult.Fail("MaxCandidates must be greater than 0");
            
        return ValidateOptionsResult.Success;
    }
}
```

#### 配置文件规范

以下是标准的配置文件结构，所有基于此基础设施的应用都应遵循此结构：

```json
{
  "AdEngine": {
    "MaxConcurrentRequests": 1000,
    "DefaultTimeout": "00:00:30", 
    "EnablePerformanceMonitoring": true,
    "EnableDebugLogging": false
  },
  "DataAccess": {
    "DefaultConnectionString": "Server=localhost;Database=AdSystem;Integrated Security=true;",
    "CommandTimeout": "00:00:30",
    "RetryCount": 3,
    "EnableConnectionPooling": true
  },
  "Strategies": {
    "UserInterestRecall": {
      "MaxCandidates": 1000,
      "CacheExpiration": "00:15:00",
      "ScoreThreshold": 0.3,
      "IsEnabled": true,
      "Priority": 100
    },
    "ContextualTargeting": {
      "MaxKeywords": 50,
      "ScoreWeight": 0.8,
      "IsEnabled": true,
      "Priority": 90
    },
    "GeographicTargeting": {
      "MaxDistanceKm": 50,
      "UseGeoFencing": true,
      "IsEnabled": true,
      "Priority": 80
    },
    "FrequencyCap": {
      "DefaultDailyLimit": 5,
      "DefaultHourlyLimit": 1,
      "IsEnabled": true,
      "Priority": 70
    }
  },
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=userdb;Database=Profiles;Integrated Security=true;",
      "CommandTimeout": "00:00:30",
      "CacheExpiration": "01:00:00",
      "IsEnabled": true,
      "RetryPolicy": {
        "MaxRetries": 3,
        "RetryInterval": "00:00:05",
        "BackoffMultiplier": 2.0
      }
    },
    "AdInventory": {
      "ConnectionString": "Server=addb;Database=Inventory;Integrated Security=true;",
      "CommandTimeout": "00:00:10",
      "IsEnabled": true,
      "CacheExpiration": "00:05:00"
    },
    "RedisCache": {
      "ConnectionString": "localhost:6379",
      "Database": 0,
      "CommandTimeout": "00:00:05",
      "IsEnabled": true
    }
  },
  "Targeting": {
    "Geographic": {
      "DefaultMaxDistanceKm": 100,
      "EnableGeoFencing": true,
      "EnableIPGeolocation": true
    },
    "Demographic": {
      "EnableAgeTargeting": true,
      "EnableGenderTargeting": true,
      "EnableIncomeTargeting": false
    },
    "Behavioral": {
      "LookbackDays": 30,
      "MinInteractionCount": 5,
      "EnableCrossSiteTracking": false
    }
  },
  "Bidding": {
    "RTB": {
      "TimeoutMs": 100,
      "EnableBidCaching": true,
      "CacheExpirationMs": 5000
    },
    "Pricing": {
      "MinBidCpmCents": 1,
      "MaxBidCpmCents": 100000,
      "DefaultBidCpmCents": 100
    }
  },
  "Creative": {
    "Validation": {
      "MaxFileSizeMB": 10,
      "AllowedFormats": ["jpg", "png", "gif", "mp4"],
      "RequireHTTPS": true
    },
    "Serving": {
      "CdnBaseUrl": "https://cdn.example.com/",
      "EnableCompression": true,
      "CacheControlMaxAge": "24:00:00"
    }
  },
  "Monitoring": {
    "HealthChecks": {
      "Enabled": true,
      "CheckIntervalSeconds": 30,
      "FailureThreshold": 3
    },
    "Metrics": {
      "Enabled": true,
      "CollectionIntervalSeconds": 60,
      "RetentionDays": 30
    },
    "Logging": {
      "MinLevel": "Information",
      "EnableFileLogging": true,
      "LogRetentionDays": 7
    }
  },
  "Security": {
    "Authentication": {
      "RequireApiKey": true,
      "ApiKeyHeader": "X-API-Key",
      "EnableJwtValidation": false
    },
    "RateLimiting": {
      "RequestsPerMinute": 1000,
      "RequestsPerHour": 50000,
      "EnableIPBlocking": true
    }
  },
  "Performance": {
    "Caching": {
      "DefaultExpiration": "00:15:00",
      "MaxMemoryUsageMB": 1024,
      "EnableDistributedCache": false
    },
    "Threading": {
      "MaxWorkerThreads": 100,
      "MaxIOThreads": 100,
      "EnableParallelProcessing": true
    }
  }
}
```

**配置文件规范说明**：

1. **顶级节点**：必须按功能模块组织，如 `AdEngine`、`DataAccess`、`Monitoring` 等
2. **策略配置**：所有策略必须放在 `Strategies` 节点下，每个策略有独立的子节点
3. **数据提供者配置**：所有数据提供者必须放在 `DataProviders` 节点下
4. **通用属性**：每个组件配置都应包含 `IsEnabled`、`Priority` 等通用属性
5. **时间格式**：必须使用 .NET TimeSpan 格式，如 `"00:15:00"` 表示15分钟
6. **连接字符串**：必须是完整的、可用的连接字符串格式
7. **数值单位**：明确标注单位，如 `MaxDistanceKm`、`TimeoutMs`、`MaxFileSizeMB`

## 实现效果

### 开发者体验

**添加新的策略组件**：
1. 创建策略类，实现 `IAdProcessingStrategy`
2. 创建配置选项类（如需要）
3. 在配置文件中添加配置节（如需要）
4. **无需任何注册代码** - 自动发现和注册

**添加新的数据提供者**：
1. 创建提供者类，实现 `IDataAccessProvider`
2. 创建配置选项类（如需要）
3. 在配置文件中添加配置节（如需要）
4. **无需任何注册代码** - 自动发现和注册

**修改配置**：
1. 直接修改配置文件
2. **无需重启应用** - 支持热重载
3. **自动验证** - 配置错误会被自动捕获

### 系统效果

**启动时**：
- 自动扫描所有程序集
- 自动发现所有组件
- 自动注册所有服务
- 自动绑定所有配置
- 自动添加健康检查

**运行时**：
- 配置热重载
- 组件健康监控
- 性能指标收集
- 错误自动恢复

**维护时**：
- 零配置添加新组件
- 配置文件驱动行为
- 统一的监控和诊断
- 标准化的错误处理

## 技术实现要点

### 配置管理技术实现

**多源配置合并**：
- JSON文件（主配置）
- 环境变量（环境特定配置）
- 命令行参数（运行时配置）
- 数据库配置（动态配置）

**配置热重载**：
- 基于 `IOptionsMonitor<T>` 实现
- 文件系统监控
- 配置变更事件通知
- 组件自动重新配置

**配置验证**：
- 数据注解验证（基础验证）
- `IValidateOptions<T>` 验证器（复杂验证）
- 启动时验证（快速失败）
- 运行时验证（配置变更时）

### 依赖注入技术实现

**程序集扫描**：
- 反射扫描所有相关程序集
- 基于接口和命名约定的类型过滤
- 元数据提取和缓存
- 并行处理提高性能

**服务生命周期管理**：
- 基于约定的自动推断
- 特性标记的显式指定
- 接口类型的智能判断
- 循环依赖检测

**配置绑定集成**：
- 组件注册时自动绑定配置
- 配置变更时自动更新
- 配置验证失败时组件隔离
- 配置默认值处理

### 健康检查和监控

**自动健康检查**：
- 实现 `IHealthCheckable` 的组件自动添加健康检查
- 配置驱动的健康检查策略
- 组件级和系统级健康状态
- 健康检查结果缓存

**性能监控**：
- 组件执行时间监控
- 配置加载性能监控
- 内存使用监控
- 错误率统计

## 预期效益

### 开发效率提升

- **零配置开发**：新增组件无需注册代码，提升开发效率 60%
- **约定优于配置**：减少样板代码，专注业务逻辑实现
- **自动化测试**：依赖注入支持，单元测试编写更简单

### 系统质量提升

- **配置管理统一**：消除配置分散问题，降低配置错误风险
- **组件管理标准化**：统一的组件生命周期管理
- **监控体系完善**：自动化的健康检查和性能监控

### 运维效率提升

- **配置热重载**：无需重启应用即可调整配置
- **统一监控**：标准化的健康检查和性能指标
- **问题诊断简化**：统一的日志和错误处理机制

这个设计提供了一个**真正可用的、开箱即用的**配置管理和依赖注入基础设施，通过约定和智能化的自动处理，实现了零配置的组件扩展能力。

## 约定规范详细说明

### 组件命名约定

#### 1. 组件类命名规范

**策略组件**：
- 命名格式：`{功能名称}Strategy`
- 必须实现：`IAdProcessingStrategy` 接口
- 示例：`UserInterestRecallStrategy`、`ContextualTargetingStrategy`、`FrequencyCapStrategy`

**服务组件**：
- 命名格式：`{功能名称}Service`
- 生命周期：单例（Singleton）
- 示例：`UserProfileService`、`AdInventoryService`、`MetricsCollectionService`

**管理器组件**：
- 命名格式：`{功能名称}Manager`
- 生命周期：单例（Singleton）
- 示例：`CampaignManager`、`BidManager`、`InventoryManager`

**数据提供者组件**：
- 命名格式：`{数据源名称}Provider`
- 必须实现：`IDataAccessProvider` 接口
- 示例：`SqlServerAdProvider`、`RedisUserProvider`、`ApiInventoryProvider`

**定向匹配器组件**：
- 命名格式：`{定向类型}Matcher`
- 必须实现：`ITargetingMatcher` 接口
- 示例：`GeographicMatcher`、`DemographicMatcher`、`BehavioralMatcher`

**计算器组件**：
- 命名格式：`{计算内容}Calculator`
- 生命周期：瞬态（Transient）
- 示例：`BidPriceCalculator`、`RevenueCalculator`、`ScoreCalculator`

**处理器组件**：
- 命名格式：`{处理内容}Processor`
- 生命周期：瞬态（Transient）
- 示例：`AdRequestProcessor`、`BidResponseProcessor`、`EventProcessor`

**回调提供者组件**：
- 命名格式：`{回调类型}CallbackProvider`
- 必须实现：`ICallbackProvider` 接口
- 生命周期：单例（Singleton）
- 示例：`AdEngineCallbackProvider`、`DataAccessCallbackProvider`、`ConfigCallbackProvider`
- 说明：为策略组件提供类型安全的回调接口访问，支持通过类型或名称获取回调实例

#### 2. 组件生命周期约定

**自动推断规则**：

| 组件类型   | 命名后缀            | 生命周期  | 理由                   |
| ---------- | ------------------- | --------- | ---------------------- |
| 管理器     | `*Manager`          | Singleton | 全局状态管理，需要单例 |
| 服务       | `*Service`          | Singleton | 无状态服务，可以复用   |
| 回调提供者 | `*CallbackProvider` | Singleton | 回调接口管理，需要单例 |
| 策略       | `*Strategy`         | Transient | 有状态处理，每次新建   |
| 计算器     | `*Calculator`       | Transient | 计算逻辑，每次新建     |
| 处理器     | `*Processor`        | Transient | 处理逻辑，每次新建     |
| 匹配器     | `*Matcher`          | Transient | 匹配逻辑，每次新建     |
| 提供者     | `*Provider`         | Scoped    | 请求范围内复用         |
| 上下文     | `*Context`          | Scoped    | 请求范围内共享         |
| 工作单元   | `*UnitOfWork`       | Scoped    | 事务范围内共享         |

**显式标记**（覆盖约定）：
```csharp
[Singleton] // 强制单例
[Scoped]    // 强制作用域
[Transient] // 强制瞬态
```

### 配置约定

#### 1. 配置类命名规范

**配置类命名**：
- 命名格式：`{模块名称}Options`
- 必须是公共类（public class）
- 建议实现：`IValidatableObject` 用于自定义验证

**自动映射规则**：
- `AdEngineOptions` → `"AdEngine"` 配置节
- `DataAccessOptions` → `"DataAccess"` 配置节
- `UserInterestRecallOptions` → 策略约定 → `"Strategies:UserInterestRecall"` 配置节

#### 2. 配置节层次结构规范

**顶级配置节**：
```json
{
  "AdEngine": {}, // 广告引擎核心配置
  "DataAccess": {}, // 数据访问配置
  "Monitoring": {}, // 监控配置
  "Security": {}, // 安全配置
  "Performance": {}, // 性能配置
  "Strategies": {}, // 策略配置集合
  "DataProviders": {}, // 数据提供者配置集合
  "Targeting": {}, // 定向配置集合
  "Bidding": {}, // 竞价配置集合
  "Creative": {}, // 创意配置集合
  "Reporting": {} // 报表配置集合
}
```

**策略配置节结构**：
```json
{
  "Strategies": {
    "UserInterestRecall": {
      "MaxCandidates": 1000,
      "ScoreThreshold": 0.3,
      "CacheExpiration": "00:15:00",
      "IsEnabled": true,
      "Priority": 100
    },
    "ContextualTargeting": {
      "MaxKeywords": 50,
      "ScoreWeight": 0.8,
      "IsEnabled": true,
      "Priority": 90
    }
  }
}
```

**数据提供者配置节结构**：
```json
{
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=userdb;Database=Profiles;",
      "CommandTimeout": "00:00:30",
      "CacheExpiration": "01:00:00",
      "IsEnabled": true,
      "RetryPolicy": {
        "MaxRetries": 3,
        "RetryInterval": "00:00:05"
      }
    },
    "AdInventory": {
      "ConnectionString": "Server=addb;Database=Inventory;",
      "CommandTimeout": "00:00:10",
      "IsEnabled": true
    }
  }
}
```

#### 3. 配置值约定

**命名约定**：
- 属性名使用 PascalCase：`MaxCandidates`、`IsEnabled`、`CacheExpiration`
- 布尔值配置建议以 `Is`、`Enable`、`Allow` 开头
- 数量配置建议以 `Max`、`Min`、`Count` 开头
- 时间配置建议以 `Timeout`、`Interval`、`Expiration` 结尾

**值格式约定**：
- 时间跨度使用 .NET TimeSpan 格式：`"00:15:00"`（15分钟）
- 连接字符串遵循标准格式
- 文件路径使用正斜杠或反斜杠转义
- URL 必须包含协议（http/https）

**通用配置属性**：
```csharp
public class BaseComponentOptions
{
    public bool IsEnabled { get; set; } = true;
    public int Priority { get; set; } = 0;
    public TimeSpan? Timeout { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}
```

### 配置绑定约定

#### 1. 自动绑定规则

**策略组件配置绑定**：
```csharp
// UserInterestRecallStrategy → "Strategies:UserInterestRecall"
// ContextualTargetingStrategy → "Strategies:ContextualTargeting"
```

**数据提供者配置绑定**：
```csharp
// SqlServerUserProvider → "DataProviders:SqlServerUser"
// RedisInventoryProvider → "DataProviders:RedisInventory"
```

**服务组件配置绑定**：
```csharp
// UserProfileService → "Services:UserProfile"
// AdInventoryService → "Services:AdInventory"
```

#### 2. 显式配置绑定

**使用特性指定**：
```csharp
[ConfigurationBinding("CustomSection:SubSection")]
public class CustomStrategy : IAdProcessingStrategy
{
    // 会绑定到 "CustomSection:SubSection" 而不是约定路径
}
```

**配置注入方式**：

#### 2.1 基本配置注入模式

**步骤1：定义配置选项类**
```csharp
// 数据提供者配置选项类 - 对应配置节 "DataProviders:UserProfile"
public class UserProfileProviderOptions
{
    public string ConnectionString { get; set; } = "";
    public TimeSpan CommandTimeout { get; set; } = TimeSpan.FromSeconds(30);
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromHours(1);
    public bool IsEnabled { get; set; } = true;
    public int MaxRetries { get; set; } = 3;
    public TimeSpan RetryInterval { get; set; } = TimeSpan.FromSeconds(5);
}
```

**步骤2：在业务组件中使用配置**
```csharp
// 数据提供者实现 - 演示如何使用配置值
public class UserProfileProvider : IDataAccessProvider, IHealthCheckable
{
    private readonly ILogger<UserProfileProvider> _logger;
    private readonly UserProfileProviderOptions _options;
    private readonly IOptionsMonitor<UserProfileProviderOptions> _optionsMonitor;

    // 推荐：使用 IOptionsMonitor 支持热重载
    public UserProfileProvider(
        IOptionsMonitor<UserProfileProviderOptions> optionsMonitor,
        ILogger<UserProfileProvider> logger)
    {
        _optionsMonitor = optionsMonitor;
        _options = optionsMonitor.CurrentValue; // 获取当前配置值
        _logger = logger;
        
        // 订阅配置变更事件，实现热重载
        _optionsMonitor.OnChange(OnConfigurationChanged);
    }

    // 配置变更时的处理逻辑
    private void OnConfigurationChanged(UserProfileProviderOptions newOptions)
    {
        _logger.LogInformation("Configuration changed for {ComponentName}", nameof(UserProfileProvider));
        
        // 更新内部配置引用
        _options = newOptions;
        
        // 重新初始化依赖配置的资源（如数据库连接池）
        ReInitializeResources();
    }

    // 使用配置值的具体示例
    public async Task<UserProfile> GetUserProfileAsync(string userId)
    {
        // 直接使用配置属性值
        using var connection = new SqlConnection(_options.ConnectionString);
        using var command = new SqlCommand("SELECT * FROM UserProfiles WHERE UserId = @UserId", connection);
        
        // 设置命令超时时间
        command.CommandTimeout = (int)_options.CommandTimeout.TotalSeconds;
        command.Parameters.AddWithValue("@UserId", userId);

        try
        {
            await connection.OpenAsync();
            // 使用配置的重试机制
            return await ExecuteWithRetryAsync(command);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get user profile for {UserId}", userId);
            throw;
        }
    }

    // 使用配置值实现重试逻辑
    private async Task<UserProfile> ExecuteWithRetryAsync(SqlCommand command)
    {
        var retryCount = 0;
        while (retryCount < _options.MaxRetries)
        {
            try
            {
                // 执行查询
                using var reader = await command.ExecuteReaderAsync();
                return MapToUserProfile(reader);
            }
            catch (SqlException ex) when (retryCount < _options.MaxRetries - 1)
            {
                retryCount++;
                _logger.LogWarning("Database query failed, retry {RetryCount}/{MaxRetries} after {Delay}ms", 
                    retryCount, _options.MaxRetries, _options.RetryInterval.TotalMilliseconds);
                    
                await Task.Delay(_options.RetryInterval);
            }
        }
        
        throw new InvalidOperationException($"Failed after {_options.MaxRetries} retries");
    }

    // 健康检查中使用配置值
    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        if (!_options.IsEnabled)
            return HealthStatus.Degraded;

        try
        {
            using var connection = new SqlConnection(_options.ConnectionString);
            connection.ConnectionTimeout = (int)_options.CommandTimeout.TotalSeconds;
            await connection.OpenAsync(cancellationToken);
            return HealthStatus.Healthy;
        }
        catch
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

**步骤3：配置文件设置**
```json
{
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=localhost;Database=AdSystem;Integrated Security=true;",
      "CommandTimeout": "00:00:30",        // 30秒超时
      "CacheExpiration": "01:00:00",       // 1小时缓存
      "IsEnabled": true,
      "MaxRetries": 3,
      "RetryInterval": "00:00:05"          // 5秒重试间隔
    }
  }
}
```

#### 2.2 简化的配置注入模式（一次性加载）

```csharp
// 对于不需要热重载的组件，可以使用 IOptions
public class SimpleCalculator : ICalculator
{
    private readonly CalculatorOptions _options;

    public SimpleCalculator(IOptions<CalculatorOptions> options)
    {
        _options = options.Value; // 一次性获取配置值，后续不会更新
    }

    public decimal CalculateBidPrice(BidRequest request)
    {
        // 直接使用配置属性
        var basePrice = _options.BasePriceCents;
        var multiplier = _options.PriceMultiplier;
        
        return basePrice * multiplier;
    }
}

public class CalculatorOptions
{
    public decimal BasePriceCents { get; set; } = 100;
    public decimal PriceMultiplier { get; set; } = 1.0m;
}
```

#### 2.3 配置验证和错误处理

```csharp
// 配置验证器示例
public class UserProfileProviderOptionsValidator : IValidateOptions<UserProfileProviderOptions>
{
    public ValidateOptionsResult Validate(string name, UserProfileProviderOptions options)
    {
        var failures = new List<string>();

        // 验证连接字符串
        if (string.IsNullOrWhiteSpace(options.ConnectionString))
            failures.Add("ConnectionString is required");

        // 验证超时时间
        if (options.CommandTimeout <= TimeSpan.Zero)
            failures.Add("CommandTimeout must be positive");

        // 验证重试配置
        if (options.MaxRetries < 0)
            failures.Add("MaxRetries cannot be negative");

        if (options.RetryInterval <= TimeSpan.Zero)
            failures.Add("RetryInterval must be positive");

        return failures.Any() 
            ? ValidateOptionsResult.Fail(failures)
            : ValidateOptionsResult.Success;
    }
}
```

#### 2.4 配置属性的数据类型约定

**时间相关配置**：
```csharp
public class ComponentOptions
{
    // .NET TimeSpan 格式："HH:mm:ss" 或 "d.HH:mm:ss"
    public TimeSpan Timeout { get; set; }           // "00:00:30" = 30秒
    public TimeSpan Interval { get; set; }          // "00:05:00" = 5分钟
    public TimeSpan CacheExpiry { get; set; }       // "24:00:00" = 24小时
}
```

**数值相关配置**：
```csharp
public class ComponentOptions
{
    public int MaxCount { get; set; }               // 整数
    public decimal PriceThreshold { get; set; }     // 金额
    public double ScoreWeight { get; set; }         // 权重分数 (0.0-1.0)
    public long MaxMemoryBytes { get; set; }        // 字节数
}
```

**字符串相关配置**：
```csharp
public class ComponentOptions
{
    public string ConnectionString { get; set; } = "";     // 连接字符串
    public string ApiEndpoint { get; set; } = "";          // URL地址
    public string LogLevel { get; set; } = "Information";  // 枚举字符串
}
```

**集合相关配置**：
```csharp
public class ComponentOptions
{
    public List<string> AllowedHosts { get; set; } = new();
    public Dictionary<string, string> Headers { get; set; } = new();
    public string[] Keywords { get; set; } = Array.Empty<string>();
}
```

**配置文件对应示例**：
```json
{
  "ComponentExample": {
    "Timeout": "00:00:30",
    "MaxCount": 1000,
    "PriceThreshold": 10.50,
    "ScoreWeight": 0.85,
    "ConnectionString": "Server=localhost;Database=Test;",
    "AllowedHosts": ["localhost", "example.com"],
    "Headers": {
      "User-Agent": "AdSystem/1.0",
      "Accept": "application/json"
    },
    "Keywords": ["advertising", "marketing", "campaign"]
  }
}
```

### 可配置接口约定

#### 1. IConfigurable 接口实现

**接口定义**：
```csharp
public interface IConfigurable
{
    /// <summary>
    /// 当配置发生变更时调用此方法重新配置组件
    /// </summary>
    /// <param name="configuration">新的配置对象</param>
    void Configure(object configuration);
    
    /// <summary>
    /// 获取组件的配置类型
    /// </summary>
    Type ConfigurationType { get; }
}
```

**使用场景**：
- 需要**自定义配置更新逻辑**的组件
- 需要在配置变更时**执行特殊初始化**的组件
- 需要**验证配置变更**是否安全的组件

#### 2. IConfigurable 接口实现示例

**基础实现模式**：
```csharp
public class AdvancedDataProvider : IDataAccessProvider, IConfigurable, IHealthCheckable
{
    private readonly ILogger<AdvancedDataProvider> _logger;
    private readonly IOptionsMonitor<AdvancedDataProviderOptions> _optionsMonitor;
    private AdvancedDataProviderOptions _options;
    private IDbConnection? _connection;

    public Type ConfigurationType => typeof(AdvancedDataProviderOptions);

    public AdvancedDataProvider(
        IOptionsMonitor<AdvancedDataProviderOptions> optionsMonitor,
        ILogger<AdvancedDataProvider> logger)
    {
        _optionsMonitor = optionsMonitor;
        _logger = logger;
        _options = optionsMonitor.CurrentValue;
        
        // 初始化配置
        Configure(_options);
        
        // 订阅配置变更
        _optionsMonitor.OnChange(newOptions => Configure(newOptions));
    }

    public void Configure(object configuration)
    {
        if (configuration is not AdvancedDataProviderOptions newOptions)
        {
            _logger.LogWarning("Invalid configuration type for {ComponentName}", nameof(AdvancedDataProvider));
            return;
        }

        var oldOptions = _options;
        _options = newOptions;

        try
        {
            // 检查关键配置是否变更
            if (oldOptions?.ConnectionString != newOptions.ConnectionString)
            {
                _logger.LogInformation("Connection string changed, reinitializing connection pool");
                ReinitializeConnection();
            }

            // 检查其他配置变更
            if (oldOptions?.CommandTimeout != newOptions.CommandTimeout)
            {
                _logger.LogInformation("Command timeout changed from {OldTimeout} to {NewTimeout}",
                    oldOptions?.CommandTimeout, newOptions.CommandTimeout);
            }

            // 验证新配置的有效性
            ValidateConfiguration(newOptions);
            
            _logger.LogInformation("Configuration updated successfully for {ComponentName}", 
                nameof(AdvancedDataProvider));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to apply new configuration, reverting to previous configuration");
            _options = oldOptions; // 回滚到旧配置
            throw;
        }
    }

    private void ReinitializeConnection()
    {
        // 关闭旧连接
        _connection?.Dispose();
        
        // 创建新连接
        _connection = new SqlConnection(_options.ConnectionString);
        
        // 测试新连接
        _connection.Open();
        _connection.Close();
    }

    private void ValidateConfiguration(AdvancedDataProviderOptions options)
    {
        if (string.IsNullOrWhiteSpace(options.ConnectionString))
            throw new InvalidOperationException("ConnectionString cannot be empty");

        if (options.CommandTimeout <= TimeSpan.Zero)
            throw new InvalidOperationException("CommandTimeout must be positive");

        // 测试连接字符串有效性
        try
        {
            using var testConnection = new SqlConnection(options.ConnectionString);
            testConnection.Open();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Invalid connection string: {ex.Message}", ex);
        }
    }

    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            if (!_options.IsEnabled)
                return HealthStatus.Degraded;

            using var connection = new SqlConnection(_options.ConnectionString);
            await connection.OpenAsync(cancellationToken);
            return HealthStatus.Healthy;
        }
        catch
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

#### 3. IConfigurable vs IOptionsMonitor 选择指南

**使用 IOptionsMonitor（推荐）**：
- 简单的配置绑定需求
- 只需要获取配置值，无特殊逻辑
- 标准的配置更新处理

```csharp
// 简单场景：只需要读取配置值
public SimpleService(IOptionsMonitor<SimpleOptions> options)
{
    _options = options.CurrentValue;
    options.OnChange(newOptions => _options = newOptions);
}
```

**使用 IConfigurable（高级场景）**：
- 需要自定义配置更新逻辑
- 配置变更时需要重新初始化资源
- 需要验证配置变更的安全性
- 需要在配置错误时回滚到旧配置

```csharp
// 复杂场景：需要自定义配置处理逻辑
public class ComplexService : IConfigurable
{
    public void Configure(object configuration)
    {
        // 自定义配置更新逻辑
        // 资源重新初始化
        // 配置验证
        // 错误处理和回滚
    }
}
```

#### 4. 配置更新最佳实践

**配置更新安全原则**：
1. **先验证后应用**：新配置必须通过验证才能应用
2. **原子更新**：配置更新要么全部成功，要么全部失败
3. **优雅降级**：配置错误时应保持服务可用性
4. **日志记录**：详细记录配置变更过程和结果

**线程安全考虑**：
```csharp
public class ThreadSafeConfigurableService : IConfigurable
{
    private readonly object _configLock = new object();
    private ServiceOptions _options;

    public void Configure(object configuration)
    {
        if (configuration is not ServiceOptions newOptions)
            return;

        lock (_configLock)
        {
            var oldOptions = _options;
            try
            {
                // 验证新配置
                ValidateConfiguration(newOptions);
                
                // 应用新配置
                _options = newOptions;
                
                // 重新初始化资源
                ReinitializeResources();
            }
            catch
            {
                // 回滚到旧配置
                _options = oldOptions;
                throw;
            }
        }
    }
}
```

### 多组件共享配置选项约定

#### 1. 问题场景

当多个业务组件使用**相同的配置选项类**，但需要从配置文件的**不同配置节**读取**不同的配置值**时，需要特殊处理。

**典型场景**：
- 多个广告引擎服务（RTB、直销、PMP）都使用 `AdEngineAbstractionsOptions`
- 多个数据提供者（主库、备库、缓存）都使用 `DataProviderOptions`
- 多个策略组件的变体都使用相同的配置结构

#### 2. 解决方案：命名选项模式（推荐）

**配置文件结构**：
```json
{
  "AdEngine": {
    "RTB": {
      "RegisterStrategyServices": true,
      "DefaultTimeout": "00:00:30",
      "MaxRetries": 3,
      "EnablePerformanceMonitoring": true
    },
    "DirectSale": {
      "RegisterStrategyServices": false,
      "DefaultTimeout": "00:01:00",
      "MaxRetries": 5,
      "EnablePerformanceMonitoring": false
    },
    "PMP": {
      "RegisterStrategyServices": true,
      "DefaultTimeout": "00:00:15",
      "MaxRetries": 2,
      "EnablePerformanceMonitoring": true
    }
  }
}
```

**服务注册配置**：

```csharp
// 业务组件使用上述基础设施扩展方法即可，无需额外配置
// services.AddAdSystemInfrastructure(configuration);
```

**业务组件实现**：
```csharp
// RTB 广告引擎服务 - 使用 "RTB" 配置
public class RTBAdEngineService : IAdEngineService, IHealthCheckable
{
    private readonly AdEngineAbstractionsOptions _options;
    private readonly ILogger<RTBAdEngineService> _logger;

    public RTBAdEngineService(
        IOptionsSnapshot<AdEngineAbstractionsOptions> optionsSnapshot,
        ILogger<RTBAdEngineService> logger)
    {
        // 使用命名配置 "RTB"
        _options = optionsSnapshot.Get("RTB");
        _logger = logger;
    }

    public async Task<AdResponse> ProcessAsync(AdRequest request)
    {
        // 使用 RTB 特定的配置值
        if (!_options.RegisterStrategyServices)
        {
            return AdResponse.Empty();
        }

        _logger.LogInformation("RTB engine using timeout: {Timeout}ms, retries: {Retries}", 
            _options.DefaultTimeout.TotalMilliseconds, _options.MaxRetries);

        // RTB 特定的业务逻辑...
        return await ProcessWithTimeoutAsync(request, _options.DefaultTimeout);
    }

    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        // 使用 RTB 配置进行健康检查
        return _options.EnablePerformanceMonitoring ? HealthStatus.Healthy : HealthStatus.Degraded;
    }
}

// 直销广告引擎服务 - 使用 "DirectSale" 配置
public class DirectSaleAdEngineService : IAdEngineService, IHealthCheckable
{
    private readonly AdEngineAbstractionsOptions _options;
    private readonly ILogger<DirectSaleAdEngineService> _logger;

    public DirectSaleAdEngineService(
        IOptionsSnapshot<AdEngineAbstractionsOptions> optionsSnapshot,
        ILogger<DirectSaleAdEngineService> logger)
    {
        // 使用命名配置 "DirectSale"
        _options = optionsSnapshot.Get("DirectSale");
        _logger = logger;
    }

    public async Task<AdResponse> ProcessAsync(AdRequest request)
    {
        // 使用直销特定的配置值（不同于RTB的配置）
        _logger.LogInformation("DirectSale engine using timeout: {Timeout}ms, retries: {Retries}", 
            _options.DefaultTimeout.TotalMilliseconds, _options.MaxRetries);

        // 直销特定的业务逻辑...
        return await ProcessWithTimeoutAsync(request, _options.DefaultTimeout);
    }

    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        // 使用直销配置进行健康检查
        return HealthStatus.Healthy;
    }
}

// PMP 广告引擎服务 - 使用 "PMP" 配置
public class PMPAdEngineService : IAdEngineService, IHealthCheckable
{
    private readonly AdEngineAbstractionsOptions _options;

    public PMPAdEngineService(IOptionsSnapshot<AdEngineAbstractionsOptions> optionsSnapshot)
    {
        // 使用命名配置 "PMP"
        _options = optionsSnapshot.Get("PMP");
    }

    public async Task<AdResponse> ProcessAsync(AdRequest request)
    {
        // 使用 PMP 特定的配置值
        var timeout = _options.DefaultTimeout; // 15秒
        var maxRetries = _options.MaxRetries;  // 2次
        
        // PMP 特定的业务逻辑...
        return await ProcessWithTimeoutAsync(request, timeout);
    }

    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        return _options.EnablePerformanceMonitoring ? HealthStatus.Healthy : HealthStatus.Degraded;
    }
}
```

#### 3. 基础设施自动处理

**自动命名选项注册**：
```csharp
public static class ConfigurationExtensions
{
    /// <summary>
    /// 自动注册多个命名配置选项
    /// </summary>
    public static IServiceCollection AddNamedOptions<TOptions>(
        this IServiceCollection services,
        IConfiguration configuration,
        string configurationSection,
        params string[] names)
        where TOptions : class
    {
        foreach (var name in names)
        {
            services.Configure<TOptions>(name, 
                configuration.GetSection($"{configurationSection}:{name}"));
        }
        
        return services;
    }
}

// 使用示例
services.AddNamedOptions<AdEngineAbstractionsOptions>(
    configuration, 
    "AdEngine", 
    "RTB", "DirectSale", "PMP");

services.AddNamedOptions<DataProviderOptions>(
    configuration, 
    "DataProviders", 
    "Primary", "Secondary", "Cache");
```

#### 4. 配置验证支持

**命名选项验证器**：
```csharp
public class AdEngineAbstractionsOptionsValidator : IValidateOptions<AdEngineAbstractionsOptions>
{
    public ValidateOptionsResult Validate(string name, AdEngineAbstractionsOptions options)
    {
        var failures = new List<string>();

        if (options.DefaultTimeout <= TimeSpan.Zero)
            failures.Add($"DefaultTimeout must be positive for {name} configuration");

        if (options.MaxRetries < 0)
            failures.Add($"MaxRetries cannot be negative for {name} configuration");

        // 根据不同的配置名称应用不同的验证规则
        switch (name)
        {
            case "RTB":
                if (options.DefaultTimeout > TimeSpan.FromSeconds(100))
                    failures.Add("RTB timeout should not exceed 100 seconds");
                break;
                
            case "DirectSale":
                if (!options.RegisterStrategyServices)
                    failures.Add("DirectSale must enable strategy services");
                break;
                
            case "PMP":
                if (options.MaxRetries > 3)
                    failures.Add("PMP should not retry more than 3 times");
                break;
        }

        return failures.Any() 
            ? ValidateOptionsResult.Fail(failures)
            : ValidateOptionsResult.Success;
    }
}

// 注册验证器
services.AddSingleton<IValidateOptions<AdEngineAbstractionsOptions>, AdEngineAbstractionsOptionsValidator>();
```

#### 5. 使用指南

**何时使用命名选项模式**：

1. **多个组件使用相同配置结构**：配置属性相同，但值不同
2. **需要类型安全的配置访问**：编译时检查配置属性
3. **需要配置验证**：确保不同场景下的配置有效性
4. **配置相对静态**：不需要运行时动态创建新的配置

**命名约定建议**：
- 使用业务含义的名称：`"RTB"`、`"DirectSale"`、`"PMP"`
- 避免技术性名称：避免 `"Config1"`、`"Config2"` 等
- 保持一致性：同类组件使用相似的命名模式

**配置路径约定**：
```json
{
  "{ComponentCategory}": {
    "{InstanceName1}": { /* 配置选项 */ },
    "{InstanceName2}": { /* 配置选项 */ },
    "{InstanceName3}": { /* 配置选项 */ }
  }
}
```

### 健康检查约定

#### 1. 健康检查接口实现

**必须实现的接口**：
```csharp
public interface IHealthCheckable
{
    Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default);
}
```

**健康状态定义**：
- `HealthStatus.Healthy`：组件正常工作
- `HealthStatus.Degraded`：组件部分功能受限但仍可用
- `HealthStatus.Unhealthy`：组件不可用

**实现示例**：
```csharp
public class UserInterestRecallStrategy : IAdProcessingStrategy, IHealthCheckable
{
    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            // 检查依赖服务
            if (!await _dataProvider.IsAvailableAsync(cancellationToken))
                return HealthStatus.Degraded;
                
            // 检查配置有效性
            if (_options.MaxCandidates <= 0)
                return HealthStatus.Unhealthy;
                
            return HealthStatus.Healthy;
        }
        catch (Exception)
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

### 验证约定

#### 1. 配置验证规范

**数据注解验证**：
```csharp
public class UserInterestRecallOptions
{
    [Range(1, 10000)]
    public int MaxCandidates { get; set; } = 1000;
    
    [Required]
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromMinutes(15);
    
    [Range(0.0, 1.0)]
    public double ScoreThreshold { get; set; } = 0.3;
}
```

**自定义验证器**：
```csharp
public class UserInterestRecallOptionsValidator : IValidateOptions<UserInterestRecallOptions>
{
    public ValidateOptionsResult Validate(string name, UserInterestRecallOptions options)
    {
        var failures = new List<string>();
        
        if (options.MaxCandidates <= 0)
            failures.Add("MaxCandidates must be greater than 0");
            
        if (options.CacheExpiration <= TimeSpan.Zero)
            failures.Add("CacheExpiration must be positive");
            
        if (options.ScoreThreshold < 0 || options.ScoreThreshold > 1)
            failures.Add("ScoreThreshold must be between 0 and 1");
            
        return failures.Any() 
            ? ValidateOptionsResult.Fail(failures)
            : ValidateOptionsResult.Success;
    }
}
```

### 特性标记约定

#### 1. 组件标记特性

**基础组件特性**：
```csharp
[Component(Priority = 100, IsEnabled = true)]
public class MyStrategy : IAdProcessingStrategy { }
```

**生命周期特性**：
```csharp
[Singleton] // 强制单例
[Scoped]    // 强制作用域
[Transient] // 强制瞬态（默认）
```

**配置绑定特性**：
```csharp
[ConfigurationBinding("CustomPath:Section")]
public class CustomComponent { }
```

**条件注册特性**：
```csharp
[ConditionalOnProperty("FeatureFlags:EnableAdvancedTargeting", Value = "true")]
public class AdvancedTargetingStrategy : IAdProcessingStrategy { }
```

#### 2. 特性使用优先级

1. **显式特性标记**（最高优先级）
2. **接口约定**（中等优先级）
3. **命名约定**（最低优先级）

### 错误处理约定

#### 1. 异常处理规范

**组件内异常处理**：
```csharp
public async Task<ProcessingResult> ProcessAsync(AdRequest request, ProcessingContext context)
{
    try
    {
        // 业务逻辑
        return new ProcessingResult { Success = true };
    }
    catch (ConfigurationException ex)
    {
        _logger.LogError(ex, "Configuration error in {ComponentName}", GetType().Name);
        return new ProcessingResult { Success = false, Error = ex.Message };
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error in {ComponentName}", GetType().Name);
        return new ProcessingResult { Success = false, Error = "Internal error" };
    }
}
```

**配置错误处理**：
- 配置验证失败时应用启动失败（快速失败原则）
- 运行时配置错误应优雅降级，不影响整体系统

**依赖错误处理**：
- 可选依赖缺失时应优雅降级
- 必需依赖缺失时应启动失败

### 日志约定

#### 1. 日志记录规范

**日志级别使用**：
- `LogCritical`：系统无法继续运行
- `LogError`：组件执行失败但系统可继续
- `LogWarning`：潜在问题或降级运行
- `LogInformation`：重要业务事件
- `LogDebug`：详细调试信息

**日志消息格式**：
```csharp
_logger.LogInformation("Processing ad request {RequestId} with {CandidateCount} candidates", 
    request.Id, candidates.Count());

_logger.LogWarning("Strategy {StrategyName} execution took {Duration}ms, exceeding threshold", 
    GetType().Name, duration.TotalMilliseconds);

_logger.LogError(ex, "Failed to process request {RequestId} in {ComponentName}", 
    request.Id, GetType().Name);
```

这些约定规范确保了基础设施的自动化程度，让开发者可以专注于业务逻辑实现，而无需关心底层的配置管理和依赖注入细节。

### 组合层设计的优势

#### 1. **避免循环引用**
- **问题**：如果将 `ServiceCollectionExtensions` 放在 `Infrastructure.Common` 中，会产生循环引用
- **解决方案**：创建独立的组合层，位于依赖关系的顶层
- **结果**：清晰的单向依赖关系，避免编译错误

#### 2. **职责分离原则**
```csharp
// 各层职责清晰分离：

// Common: 提供基础抽象和接口
public interface IHealthCheckable { }
public interface IComponent { }

// Configuration: 专注配置管理
public class AdSystemConfigurationManager { }

// DependencyInjection: 专注组件注册
public class ComponentRegistrationManager { }

// Composition: 专注组装协调
public class InfrastructureBootstrapper { }
public static class ServiceCollectionExtensions { }
```

#### 3. **可测试性增强**
- **独立测试**：每个基础设施组件可以独立测试
- **集成测试**：组合层提供明确的集成测试入口
- **模拟依赖**：各层之间的依赖关系清晰，便于模拟测试

#### 4. **可维护性提升**
- **单一职责**：每个项目只负责自己的核心功能
- **低耦合**：各基础设施组件之间松耦合
- **高内聚**：相关功能集中在同一个项目中

### 项目引用关系

```
项目引用关系（单向依赖）：

Lorn.ADSP.Infrastructure.Composition
├─ 引用 → Lorn.ADSP.Infrastructure.Configuration
├─ 引用 → Lorn.ADSP.Infrastructure.DependencyInjection
└─ 引用 → Lorn.ADSP.Infrastructure.Common

Lorn.ADSP.Infrastructure.Configuration
└─ 引用 → Lorn.ADSP.Infrastructure.Common

Lorn.ADSP.Infrastructure.DependencyInjection
└─ 引用 → Lorn.ADSP.Infrastructure.Common

Lorn.ADSP.Infrastructure.Common
└─ 无向上引用（提供基础抽象）
```

### NuGet 包设计建议

如果将来要发布为 NuGet 包，可以采用以下策略：

- **Lorn.ADSP.Infrastructure**：主包，包含组合层，用户只需安装这一个包
- **Lorn.ADSP.Infrastructure.Configuration**：可选的配置扩展包
- **Lorn.ADSP.Infrastructure.DependencyInjection**：可选的 DI 扩展包
- **Lorn.ADSP.Infrastructure.Common**：基础包，被其他包依赖
