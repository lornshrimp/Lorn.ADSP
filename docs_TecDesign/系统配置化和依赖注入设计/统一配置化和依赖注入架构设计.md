# 统一配置化和依赖注入架构设计

# 统一配置化和依赖注入架构设计

## 设计目标

为 Lorn.ADSP 广告平台设计一个统一的配置管理和依赖注入基础设施，解决当前系统中配置和组件注册分散、缺乏标准的问题。

**核心目标**：
- **统一配置管理**：提供标准化的配置加载、验证、热重载机制
- **统一组件注册**：提供标准化的组件发现、注册、生命周期管理
- **零配置扩展**：新增配置项和组件时无需修改基础设施代码
- **开箱即用**：基于约定和元数据，自动完成配置绑定和组件注册

## 基础设施项目结构

### 项目组织架构

```text
Infrastructure/
├── Lorn.ADSP.Infrastructure.Configuration/       # 配置管理基础设施
│   ├── Providers/                               # 配置提供者实现
│   │   ├── JsonConfigurationProvider.cs        # JSON文件配置
│   │   ├── EnvironmentConfigurationProvider.cs # 环境变量配置
│   │   ├── DatabaseConfigurationProvider.cs    # 数据库配置
│   │   └── CompositeConfigurationProvider.cs   # 组合配置源
│   ├── Validation/                              # 配置验证器
│   │   ├── ConfigurationValidator.cs           # 核心验证器
│   │   ├── ValidationRuleEngine.cs             # 验证规则引擎
│   │   └── ValidationResult.cs                 # 验证结果模型
│   ├── Binding/                                # 配置绑定器
│   │   ├── TypedConfigurationBinder.cs         # 强类型绑定
│   │   ├── ConventionConfigurationBinder.cs    # 约定绑定
│   │   └── ConfigurationChangeTracker.cs       # 变更跟踪
│   ├── Extensions/                              # 扩展方法
│   │   ├── ServiceCollectionExtensions.cs      # DI容器扩展
│   │   └── ConfigurationBuilderExtensions.cs   # 配置构建器扩展
│   └── Models/                                  # 配置模型
│       ├── ConfigurationSchema.cs              # 配置架构定义
│       ├── ConfigurationMetadata.cs            # 配置元数据
│       └── ConfigurationOptions.cs             # 基础配置选项
├── Lorn.ADSP.Infrastructure.DependencyInjection/ # 依赖注入基础设施
│   ├── Discovery/                               # 组件发现器
│   │   ├── AssemblyComponentScanner.cs         # 程序集扫描器
│   │   ├── ConventionComponentDiscovery.cs     # 约定发现器
│   │   └── MetadataComponentFilter.cs          # 元数据过滤器
│   ├── Registration/                            # 组件注册器
│   │   ├── ComponentRegistrationBuilder.cs     # 注册构建器
│   │   ├── BatchComponentRegistrar.cs          # 批量注册器
│   │   └── LifecycleManager.cs                 # 生命周期管理
│   ├── Attributes/                              # 特性标记
│   │   ├── ComponentAttribute.cs               # 组件标记
│   │   ├── ConfigurationBindingAttribute.cs    # 配置绑定标记
│   │   └── DependencyAttribute.cs              # 依赖声明标记
│   ├── Extensions/                              # 扩展方法
│   │   ├── ServiceCollectionExtensions.cs      # DI容器扩展
│   │   └── ComponentRegistrationExtensions.cs  # 组件注册扩展
│   └── Models/                                  # 组件模型
│       ├── ComponentDescriptor.cs              # 组件描述符
│       ├── ComponentMetadata.cs                # 组件元数据
│       └── RegistrationOptions.cs              # 注册选项
└── Lorn.ADSP.Infrastructure.Common/             # 公共基础设施
    ├── Abstractions/                            # 基础抽象
    │   ├── IConfigurable.cs                    # 可配置接口
    │   ├── IComponent.cs                       # 组件基础接口
    │   └── IHealthCheckable.cs                 # 健康检查接口
    ├── Base/                                    # 基础类
    │   ├── ConfigurableComponentBase.cs        # 可配置组件基类
    │   ├── ComponentBase.cs                    # 组件基类
    │   └── HealthCheckableComponentBase.cs     # 健康检查组件基类
    ├── Conventions/                             # 约定规范
    │   ├── NamingConventions.cs                # 命名约定
    │   ├── ConfigurationConventions.cs         # 配置约定
    │   └── ComponentConventions.cs             # 组件约定
    └── Extensions/                              # 通用扩展
        ├── TypeExtensions.cs                   # 类型扩展
        ├── ReflectionExtensions.cs             # 反射扩展
        └── ValidationExtensions.cs             # 验证扩展
```

### 各项目功能职责

#### Lorn.ADSP.Infrastructure.Configuration

**核心职责**：提供统一的配置管理基础设施

**主要功能**：
- **多源配置支持**：JSON文件、环境变量、数据库、命令行参数
- **强类型绑定**：自动将配置映射到强类型对象
- **配置验证**：支持数据注解和自定义验证规则
- **热重载机制**：配置文件变更时自动重新加载
- **配置合并**：支持多环境配置的层次化合并
- **配置加密**：敏感配置的加密存储和解密

#### Lorn.ADSP.Infrastructure.DependencyInjection

**核心职责**：提供统一的组件注册和依赖注入基础设施

**主要功能**：
- **组件自动发现**：基于约定和特性自动扫描组件
- **批量注册**：支持程序集级别的批量组件注册
- **生命周期管理**：自动推断和管理组件生命周期
- **配置绑定集成**：组件注册时自动绑定配置
- **条件注册**：基于环境或配置的条件注册
- **装饰器支持**：非侵入式的组件功能增强

#### Lorn.ADSP.Infrastructure.Common

**核心职责**：提供公共的基础设施和约定规范

**主要功能**：
- **基础接口定义**：定义组件的基础能力接口
- **基础类实现**：提供常用的基础类实现
- **约定规范**：定义命名、配置、组件的约定规范
- **通用扩展方法**：提供常用的扩展方法和工具类

## 核心设计理念

### 1. 配置管理是基础设施，不是业务扩展点

**配置管理的本质**：
- 配置管理应该是一个**完整的、开箱即用的基础设施**
- 当增加新的配置项时，只需要**添加配置内容**，无需修改配置管理代码
- 通过**约定和元数据**实现零配置的自动绑定

**错误的设计**：把配置管理设计成接口，每次新增配置都要写新的实现
**正确的设计**：配置管理是具体实现，通过约定自动处理各种配置

### 2. 依赖注入是组件组装工具，不是业务逻辑

**依赖注入的本质**：
- 依赖注入应该是一个**智能的组件组装器**
- 当增加新的组件时，只需要**标记组件特性**，无需修改注册代码
- 通过**程序集扫描和约定**实现自动发现和注册

**错误的设计**：把每种业务组件都设计成需要专门的注册器
**正确的设计**：一个通用的注册器，通过元数据和约定处理所有类型的组件

### 3. 基于约定的零配置设计

约定规范是整个基础设施的核心，所有业务组件开发者必须遵循这些约定才能享受零配置的便利。

## 具体实现设计

### 配置管理实现

#### 核心配置管理器

```csharp
// 统一的配置管理器 - 这是具体实现，不是接口
public class AdSystemConfigurationManager
{
    private readonly IConfiguration _configuration;
    private readonly IServiceCollection _services;
    private readonly Dictionary<Type, object> _cachedOptions = new();
    
    // 自动注册所有 *Options 类型的配置
    public void RegisterAllOptions()
    {
        var optionsTypes = AssemblyScanner.FindTypes(type => 
            type.Name.EndsWith("Options") && 
            type.IsClass && 
            !type.IsAbstract);
            
        foreach (var optionsType in optionsTypes)
        {
            RegisterOptions(optionsType);
        }
    }
    
    // 根据约定自动绑定配置
    private void RegisterOptions(Type optionsType)
    {
        // 约定：AdEngineOptions -> "AdEngine" 配置节
        var sectionName = optionsType.Name.Replace("Options", "");
        
        // 使用 Microsoft.Extensions.Options 进行强类型绑定
        var configureMethod = typeof(OptionsConfigurationServiceCollectionExtensions)
            .GetMethod("Configure", new[] { typeof(IServiceCollection), typeof(IConfiguration) })
            .MakeGenericMethod(optionsType);
            
        configureMethod.Invoke(null, new object[] { 
            _services, 
            _configuration.GetSection(sectionName) 
        });
        
        // 自动添加验证器（如果存在）
        RegisterValidatorIfExists(optionsType);
    }
}
```

#### 配置验证器

```csharp
// 统一的配置验证器 - 具体实现
public class ConfigurationValidationManager
{
    // 自动扫描和注册所有验证器
    public void RegisterAllValidators(IServiceCollection services)
    {
        var validatorTypes = AssemblyScanner.FindTypes(type => 
            type.IsClass && 
            !type.IsAbstract &&
            type.GetInterfaces().Any(i => 
                i.IsGenericType && 
                i.GetGenericTypeDefinition() == typeof(IValidateOptions<>)));
                
        foreach (var validatorType in validatorTypes)
        {
            var optionsType = validatorType.GetInterfaces()
                .First(i => i.IsGenericType && i.GetGenericTypeDefinition() == typeof(IValidateOptions<>))
                .GetGenericArguments()[0];
                
            var serviceType = typeof(IValidateOptions<>).MakeGenericType(optionsType);
            services.AddSingleton(serviceType, validatorType);
        }
    }
}
```

### 依赖注入实现

#### 智能组件注册器

```csharp
// 智能组件注册器 - 这是具体实现，通过约定处理所有组件类型
public class ComponentRegistrationManager
{
    private readonly IServiceCollection _services;
    private readonly IConfiguration _configuration;
    
    // 一键注册所有组件 - 这是使用者唯一需要调用的方法
    public void RegisterAllComponents()
    {
        // 1. 扫描所有程序集
        var assemblies = GetRelevantAssemblies();
        
        foreach (var assembly in assemblies)
        {
            // 2. 发现所有组件
            var components = DiscoverComponents(assembly);
            
            // 3. 批量注册组件
            RegisterComponents(components);
        }
    }
    
    // 组件发现逻辑
    private IEnumerable<ComponentInfo> DiscoverComponents(Assembly assembly)
    {
        var componentTypes = assembly.GetTypes()
            .Where(type => type.IsClass && !type.IsAbstract)
            .Where(IsComponent); // 基于约定判断是否为组件
            
        return componentTypes.Select(type => new ComponentInfo
        {
            ImplementationType = type,
            ServiceTypes = GetServiceTypes(type), // 自动推断服务类型
            Lifetime = GetServiceLifetime(type),  // 自动推断生命周期
            ConfigurationSection = GetConfigurationSection(type), // 自动推断配置节
            Metadata = ExtractMetadata(type) // 提取元数据
        });
    }
    
    // 基于约定的组件识别
    private bool IsComponent(Type type)
    {
        // 约定1：实现已知的业务接口
        if (typeof(IAdProcessingStrategy).IsAssignableFrom(type) ||
            typeof(IDataAccessProvider).IsAssignableFrom(type) ||
            typeof(ITargetingMatcher).IsAssignableFrom(type))
            return true;
            
        // 约定2：标记了 [Component] 特性
        if (type.GetCustomAttribute<ComponentAttribute>() != null)
            return true;
            
        // 约定3：符合命名约定（以 Service、Manager、Provider、Strategy 等结尾）
        var componentSuffixes = new[] { "Service", "Manager", "Provider", "Strategy", "Calculator", "Processor" };
        if (componentSuffixes.Any(suffix => type.Name.EndsWith(suffix)))
            return true;
            
        return false;
    }
    
    // 自动推断服务生命周期
    private ServiceLifetime GetServiceLifetime(Type type)
    {
        // 约定1：显式标记
        if (type.GetCustomAttribute<SingletonAttribute>() != null) return ServiceLifetime.Singleton;
        if (type.GetCustomAttribute<ScopedAttribute>() != null) return ServiceLifetime.Scoped;
        if (type.GetCustomAttribute<TransientAttribute>() != null) return ServiceLifetime.Transient;
        
        // 约定2：根据命名推断
        if (type.Name.EndsWith("Manager") || type.Name.EndsWith("Service")) return ServiceLifetime.Singleton;
        if (type.Name.EndsWith("Context") || type.Name.EndsWith("UnitOfWork")) return ServiceLifetime.Scoped;
        if (type.Name.EndsWith("Strategy") || type.Name.EndsWith("Calculator")) return ServiceLifetime.Transient;
        
        // 约定3：根据接口推断
        if (typeof(IDisposable).IsAssignableFrom(type)) return ServiceLifetime.Scoped;
        
        // 默认为瞬态
        return ServiceLifetime.Transient;
    }
    
    // 自动推断配置节
    private string GetConfigurationSection(Type type)
    {
        // 显式指定
        var configAttr = type.GetCustomAttribute<ConfigurationBindingAttribute>();
        if (configAttr != null) return configAttr.SectionName;
        
        // 约定推断：UserInterestRecallStrategy -> "Strategies:UserInterestRecall"
        if (typeof(IAdProcessingStrategy).IsAssignableFrom(type))
        {
            var strategyName = type.Name.Replace("Strategy", "");
            return $"Strategies:{strategyName}";
        }
        
        if (typeof(IDataAccessProvider).IsAssignableFrom(type))
        {
            var providerName = type.Name.Replace("Provider", "");
            return $"DataProviders:{providerName}";
        }
        
        // 其他约定...
        return null;
    }
}
```

### 使用示例

#### 应用程序配置

```csharp
// Program.cs - 使用者只需要调用一个方法
public class Program
{
    public static void Main(string[] args)
    {
        var host = Host.CreateDefaultBuilder(args)
            .ConfigureServices((context, services) =>
            {
                // 一键配置整个广告系统 - 这是使用者唯一需要的代码
                services.AddAdSystemInfrastructure(context.Configuration);
            })
            .Build();
            
        host.Run();
    }
}

// 扩展方法实现
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddAdSystemInfrastructure(
        this IServiceCollection services, 
        IConfiguration configuration)
    {
        // 1. 配置管理
        var configManager = new AdSystemConfigurationManager(configuration, services);
        configManager.RegisterAllOptions(); // 自动注册所有 *Options 类
        
        // 2. 配置验证
        var validationManager = new ConfigurationValidationManager();
        validationManager.RegisterAllValidators(services); // 自动注册所有验证器
        
        // 3. 组件注册
        var componentManager = new ComponentRegistrationManager(services, configuration);
        componentManager.RegisterAllComponents(); // 自动注册所有组件
        
        // 4. 健康检查（自动为所有组件添加）
        services.AddHealthChecks()
                .AddComponentHealthChecks(); // 自动为实现 IHealthCheckable 的组件添加健康检查
        
        return services;
    }
}

```

#### 业务组件实现示例

```csharp
// 广告策略实现 - 开发者只需要实现业务逻辑，无需关心注册
[Component] // 可选，根据命名约定也会自动发现
[ConfigurationBinding("Strategies:UserInterestRecall")] // 可选，根据约定也会自动推断
public class UserInterestRecallStrategy : IAdProcessingStrategy
{
    private readonly UserInterestRecallOptions _options;
    
    // 配置会自动注入
    public UserInterestRecallStrategy(IOptions<UserInterestRecallOptions> options)
    {
        _options = options.Value;
    }
    
    // 实现业务逻辑即可
    public async Task<ProcessingResult> ProcessAsync(AdRequest request, ProcessingContext context)
    {
        // 业务逻辑实现...
    }
}

// 配置选项 - 会自动绑定到 "Strategies:UserInterestRecall" 配置节
public class UserInterestRecallOptions
{
    public int MaxCandidates { get; set; } = 100;
    public TimeSpan CacheExpiry { get; set; } = TimeSpan.FromMinutes(30);
    public bool EnableDebugLogging { get; set; } = false;
}

// 配置验证器 - 会自动发现并注册
public class UserInterestRecallOptionsValidator : IValidateOptions<UserInterestRecallOptions>
{
    public ValidateOptionsResult Validate(string name, UserInterestRecallOptions options)
    {
        if (options.MaxCandidates <= 0)
            return ValidateOptionsResult.Fail("MaxCandidates must be greater than 0");
            
        return ValidateOptionsResult.Success;
    }
}
```

#### 配置文件规范

以下是标准的配置文件结构，所有基于此基础设施的应用都应遵循此结构：

```json
{
  "AdEngine": {
    "MaxConcurrentRequests": 1000,
    "DefaultTimeout": "00:00:30", 
    "EnablePerformanceMonitoring": true,
    "EnableDebugLogging": false
  },
  "DataAccess": {
    "DefaultConnectionString": "Server=localhost;Database=AdSystem;Integrated Security=true;",
    "CommandTimeout": "00:00:30",
    "RetryCount": 3,
    "EnableConnectionPooling": true
  },
  "Strategies": {
    "UserInterestRecall": {
      "MaxCandidates": 1000,
      "CacheExpiration": "00:15:00",
      "ScoreThreshold": 0.3,
      "IsEnabled": true,
      "Priority": 100
    },
    "ContextualTargeting": {
      "MaxKeywords": 50,
      "ScoreWeight": 0.8,
      "IsEnabled": true,
      "Priority": 90
    },
    "GeographicTargeting": {
      "MaxDistanceKm": 50,
      "UseGeoFencing": true,
      "IsEnabled": true,
      "Priority": 80
    },
    "FrequencyCap": {
      "DefaultDailyLimit": 5,
      "DefaultHourlyLimit": 1,
      "IsEnabled": true,
      "Priority": 70
    }
  },
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=userdb;Database=Profiles;Integrated Security=true;",
      "CommandTimeout": "00:00:30",
      "CacheExpiration": "01:00:00",
      "IsEnabled": true,
      "RetryPolicy": {
        "MaxRetries": 3,
        "RetryInterval": "00:00:05",
        "BackoffMultiplier": 2.0
      }
    },
    "AdInventory": {
      "ConnectionString": "Server=addb;Database=Inventory;Integrated Security=true;",
      "CommandTimeout": "00:00:10",
      "IsEnabled": true,
      "CacheExpiration": "00:05:00"
    },
    "RedisCache": {
      "ConnectionString": "localhost:6379",
      "Database": 0,
      "CommandTimeout": "00:00:05",
      "IsEnabled": true
    }
  },
  "Targeting": {
    "Geographic": {
      "DefaultMaxDistanceKm": 100,
      "EnableGeoFencing": true,
      "EnableIPGeolocation": true
    },
    "Demographic": {
      "EnableAgeTargeting": true,
      "EnableGenderTargeting": true,
      "EnableIncomeTargeting": false
    },
    "Behavioral": {
      "LookbackDays": 30,
      "MinInteractionCount": 5,
      "EnableCrossSiteTracking": false
    }
  },
  "Bidding": {
    "RTB": {
      "TimeoutMs": 100,
      "EnableBidCaching": true,
      "CacheExpirationMs": 5000
    },
    "Pricing": {
      "MinBidCpmCents": 1,
      "MaxBidCpmCents": 100000,
      "DefaultBidCpmCents": 100
    }
  },
  "Creative": {
    "Validation": {
      "MaxFileSizeMB": 10,
      "AllowedFormats": ["jpg", "png", "gif", "mp4"],
      "RequireHTTPS": true
    },
    "Serving": {
      "CdnBaseUrl": "https://cdn.example.com/",
      "EnableCompression": true,
      "CacheControlMaxAge": "24:00:00"
    }
  },
  "Monitoring": {
    "HealthChecks": {
      "Enabled": true,
      "CheckIntervalSeconds": 30,
      "FailureThreshold": 3
    },
    "Metrics": {
      "Enabled": true,
      "CollectionIntervalSeconds": 60,
      "RetentionDays": 30
    },
    "Logging": {
      "MinLevel": "Information",
      "EnableFileLogging": true,
      "LogRetentionDays": 7
    }
  },
  "Security": {
    "Authentication": {
      "RequireApiKey": true,
      "ApiKeyHeader": "X-API-Key",
      "EnableJwtValidation": false
    },
    "RateLimiting": {
      "RequestsPerMinute": 1000,
      "RequestsPerHour": 50000,
      "EnableIPBlocking": true
    }
  },
  "Performance": {
    "Caching": {
      "DefaultExpiration": "00:15:00",
      "MaxMemoryUsageMB": 1024,
      "EnableDistributedCache": false
    },
    "Threading": {
      "MaxWorkerThreads": 100,
      "MaxIOThreads": 100,
      "EnableParallelProcessing": true
    }
  }
}
```

**配置文件规范说明**：

1. **顶级节点**：必须按功能模块组织，如 `AdEngine`、`DataAccess`、`Strategies` 等
2. **策略配置**：所有策略必须放在 `Strategies` 节点下，每个策略有独立的子节点
3. **数据提供者配置**：所有数据提供者必须放在 `DataProviders` 节点下
4. **通用属性**：每个组件配置都应包含 `IsEnabled`、`Priority` 等通用属性
5. **时间格式**：必须使用 .NET TimeSpan 格式，如 `"00:15:00"` 表示15分钟
6. **连接字符串**：必须是完整的、可用的连接字符串格式
7. **数值单位**：明确标注单位，如 `MaxDistanceKm`、`TimeoutMs`、`MaxFileSizeMB`

## 实现效果

### 开发者体验

**添加新的策略组件**：
1. 创建策略类，实现 `IAdProcessingStrategy`
2. 创建配置选项类（如需要）
3. 在配置文件中添加配置节（如需要）
4. **无需任何注册代码** - 自动发现和注册

**添加新的数据提供者**：
1. 创建提供者类，实现 `IDataAccessProvider`
2. 创建配置选项类（如需要）
3. 在配置文件中添加配置节（如需要）
4. **无需任何注册代码** - 自动发现和注册

**修改配置**：
1. 直接修改配置文件
2. **无需重启应用** - 支持热重载
3. **自动验证** - 配置错误会被自动捕获

### 系统效果

**启动时**：
- 自动扫描所有程序集
- 自动发现所有组件
- 自动注册所有服务
- 自动绑定所有配置
- 自动添加健康检查

**运行时**：
- 配置热重载
- 组件健康监控
- 性能指标收集
- 错误自动恢复

**维护时**：
- 零配置添加新组件
- 配置文件驱动行为
- 统一的监控和诊断
- 标准化的错误处理

## 技术实现要点

### 配置管理技术实现

**多源配置合并**：
- JSON文件（主配置）
- 环境变量（环境特定配置）
- 命令行参数（运行时配置）
- 数据库配置（动态配置）

**配置热重载**：
- 基于 `IOptionsMonitor<T>` 实现
- 文件系统监控
- 配置变更事件通知
- 组件自动重新配置

**配置验证**：
- 数据注解验证（基础验证）
- `IValidateOptions<T>` 验证器（复杂验证）
- 启动时验证（快速失败）
- 运行时验证（配置变更时）

### 依赖注入技术实现

**程序集扫描**：
- 反射扫描所有相关程序集
- 基于接口和命名约定的类型过滤
- 元数据提取和缓存
- 并行处理提高性能

**服务生命周期管理**：
- 基于约定的自动推断
- 特性标记的显式指定
- 接口类型的智能判断
- 循环依赖检测

**配置绑定集成**：
- 组件注册时自动绑定配置
- 配置变更时自动更新
- 配置验证失败时组件隔离
- 配置默认值处理

### 健康检查和监控

**自动健康检查**：
- 实现 `IHealthCheckable` 的组件自动添加健康检查
- 配置驱动的健康检查策略
- 组件级和系统级健康状态
- 健康检查结果缓存

**性能监控**：
- 组件执行时间监控
- 配置加载性能监控
- 内存使用监控
- 错误率统计

## 预期效益

### 开发效率提升

- **零配置开发**：新增组件无需注册代码，提升开发效率 60%
- **约定优于配置**：减少样板代码，专注业务逻辑实现
- **自动化测试**：依赖注入支持，单元测试编写更简单

### 系统质量提升

- **配置管理统一**：消除配置分散问题，降低配置错误风险
- **组件管理标准化**：统一的组件生命周期管理
- **监控体系完善**：自动化的健康检查和性能监控

### 运维效率提升

- **配置热重载**：无需重启应用即可调整配置
- **统一监控**：标准化的健康检查和性能指标
- **问题诊断简化**：统一的日志和错误处理机制

这个设计提供了一个**真正可用的、开箱即用的**配置管理和依赖注入基础设施，通过约定和智能化的自动处理，实现了零配置的组件扩展能力。

## 约定规范详细说明

### 组件命名约定

#### 1. 组件类命名规范

**策略组件**：
- 命名格式：`{功能名称}Strategy`
- 必须实现：`IAdProcessingStrategy` 接口
- 示例：`UserInterestRecallStrategy`、`ContextualTargetingStrategy`、`FrequencyCapStrategy`

**服务组件**：
- 命名格式：`{功能名称}Service`
- 生命周期：单例（Singleton）
- 示例：`UserProfileService`、`AdInventoryService`、`MetricsCollectionService`

**管理器组件**：
- 命名格式：`{功能名称}Manager`
- 生命周期：单例（Singleton）
- 示例：`CampaignManager`、`BidManager`、`InventoryManager`

**数据提供者组件**：
- 命名格式：`{数据源名称}Provider`
- 必须实现：`IDataAccessProvider` 接口
- 示例：`SqlServerAdProvider`、`RedisUserProvider`、`ApiInventoryProvider`

**定向匹配器组件**：
- 命名格式：`{定向类型}Matcher`
- 必须实现：`ITargetingMatcher` 接口
- 示例：`GeographicMatcher`、`DemographicMatcher`、`BehavioralMatcher`

**计算器组件**：
- 命名格式：`{计算内容}Calculator`
- 生命周期：瞬态（Transient）
- 示例：`BidPriceCalculator`、`RevenueCalculator`、`ScoreCalculator`

**处理器组件**：
- 命名格式：`{处理内容}Processor`
- 生命周期：瞬态（Transient）
- 示例：`AdRequestProcessor`、`BidResponseProcessor`、`EventProcessor`

**回调提供者组件**：
- 命名格式：`{回调类型}CallbackProvider`
- 必须实现：`ICallbackProvider` 接口
- 生命周期：单例（Singleton）
- 示例：`AdEngineCallbackProvider`、`DataAccessCallbackProvider`、`ConfigCallbackProvider`
- 说明：为策略组件提供类型安全的回调接口访问，支持通过类型或名称获取回调实例

#### 2. 组件生命周期约定

**自动推断规则**：

| 组件类型   | 命名后缀            | 生命周期  | 理由                   |
| ---------- | ------------------- | --------- | ---------------------- |
| 管理器     | `*Manager`          | Singleton | 全局状态管理，需要单例 |
| 服务       | `*Service`          | Singleton | 无状态服务，可以复用   |
| 回调提供者 | `*CallbackProvider` | Singleton | 回调接口管理，需要单例 |
| 策略       | `*Strategy`         | Transient | 有状态处理，每次新建   |
| 计算器     | `*Calculator`       | Transient | 计算逻辑，每次新建     |
| 处理器     | `*Processor`        | Transient | 处理逻辑，每次新建     |
| 匹配器     | `*Matcher`          | Transient | 匹配逻辑，每次新建     |
| 提供者     | `*Provider`         | Scoped    | 请求范围内复用         |
| 上下文     | `*Context`          | Scoped    | 请求范围内共享         |
| 工作单元   | `*UnitOfWork`       | Scoped    | 事务范围内共享         |

**显式标记**（覆盖约定）：
```csharp
[Singleton] // 强制单例
[Scoped]    // 强制作用域
[Transient] // 强制瞬态
```

### 配置约定

#### 1. 配置类命名规范

**配置类命名**：
- 命名格式：`{模块名称}Options`
- 必须是公共类（public class）
- 建议实现：`IValidatableObject` 用于自定义验证

**自动映射规则**：
- `AdEngineOptions` → `"AdEngine"` 配置节
- `DataAccessOptions` → `"DataAccess"` 配置节
- `UserInterestRecallOptions` → 策略约定 → `"Strategies:UserInterestRecall"` 配置节

#### 2. 配置节层次结构规范

**顶级配置节**：
```json
{
  "AdEngine": {}, // 广告引擎核心配置
  "DataAccess": {}, // 数据访问配置
  "Monitoring": {}, // 监控配置
  "Security": {}, // 安全配置
  "Performance": {}, // 性能配置
  "Strategies": {}, // 策略配置集合
  "DataProviders": {}, // 数据提供者配置集合
  "Targeting": {}, // 定向配置集合
  "Bidding": {}, // 竞价配置集合
  "Creative": {}, // 创意配置集合
  "Reporting": {} // 报表配置集合
}
```

**策略配置节结构**：
```json
{
  "Strategies": {
    "UserInterestRecall": {
      "MaxCandidates": 1000,
      "ScoreThreshold": 0.3,
      "CacheExpiration": "00:15:00",
      "IsEnabled": true,
      "Priority": 100
    },
    "ContextualTargeting": {
      "MaxKeywords": 50,
      "ScoreWeight": 0.8,
      "IsEnabled": true,
      "Priority": 90
    }
  }
}
```

**数据提供者配置节结构**：
```json
{
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=userdb;Database=Profiles;",
      "CommandTimeout": "00:00:30",
      "CacheExpiration": "01:00:00",
      "IsEnabled": true,
      "RetryPolicy": {
        "MaxRetries": 3,
        "RetryInterval": "00:00:05"
      }
    },
    "AdInventory": {
      "ConnectionString": "Server=addb;Database=Inventory;",
      "CommandTimeout": "00:00:10",
      "IsEnabled": true
    }
  }
}
```

#### 3. 配置值约定

**命名约定**：
- 属性名使用 PascalCase：`MaxCandidates`、`IsEnabled`、`CacheExpiration`
- 布尔值配置建议以 `Is`、`Enable`、`Allow` 开头
- 数量配置建议以 `Max`、`Min`、`Count` 开头
- 时间配置建议以 `Timeout`、`Interval`、`Expiration` 结尾

**值格式约定**：
- 时间跨度使用 .NET TimeSpan 格式：`"00:15:00"`（15分钟）
- 连接字符串遵循标准格式
- 文件路径使用正斜杠或反斜杠转义
- URL 必须包含协议（http/https）

**通用配置属性**：
```csharp
public class BaseComponentOptions
{
    public bool IsEnabled { get; set; } = true;
    public int Priority { get; set; } = 0;
    public TimeSpan? Timeout { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}
```

### 配置绑定约定

#### 1. 自动绑定规则

**策略组件配置绑定**：
```csharp
// UserInterestRecallStrategy → "Strategies:UserInterestRecall"
// ContextualTargetingStrategy → "Strategies:ContextualTargeting"
```

**数据提供者配置绑定**：
```csharp
// SqlServerUserProvider → "DataProviders:SqlServerUser"
// RedisInventoryProvider → "DataProviders:RedisInventory"
```

**服务组件配置绑定**：
```csharp
// UserProfileService → "Services:UserProfile"
// AdInventoryService → "Services:AdInventory"
```

#### 2. 显式配置绑定

**使用特性指定**：
```csharp
[ConfigurationBinding("CustomSection:SubSection")]
public class CustomStrategy : IAdProcessingStrategy
{
    // 会绑定到 "CustomSection:SubSection" 而不是约定路径
}
```

**配置注入方式**：

#### 2.1 基本配置注入模式

**步骤1：定义配置选项类**
```csharp
// 数据提供者配置选项类 - 对应配置节 "DataProviders:UserProfile"
public class UserProfileProviderOptions
{
    public string ConnectionString { get; set; } = "";
    public TimeSpan CommandTimeout { get; set; } = TimeSpan.FromSeconds(30);
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromHours(1);
    public bool IsEnabled { get; set; } = true;
    public int MaxRetries { get; set; } = 3;
    public TimeSpan RetryInterval { get; set; } = TimeSpan.FromSeconds(5);
}
```

**步骤2：在业务组件中使用配置**
```csharp
// 数据提供者实现 - 演示如何使用配置值
public class UserProfileProvider : IDataAccessProvider, IHealthCheckable
{
    private readonly ILogger<UserProfileProvider> _logger;
    private readonly UserProfileProviderOptions _options;
    private readonly IOptionsMonitor<UserProfileProviderOptions> _optionsMonitor;

    // 推荐：使用 IOptionsMonitor 支持热重载
    public UserProfileProvider(
        IOptionsMonitor<UserProfileProviderOptions> optionsMonitor,
        ILogger<UserProfileProvider> logger)
    {
        _optionsMonitor = optionsMonitor;
        _options = optionsMonitor.CurrentValue; // 获取当前配置值
        _logger = logger;
        
        // 订阅配置变更事件，实现热重载
        _optionsMonitor.OnChange(OnConfigurationChanged);
    }

    // 配置变更时的处理逻辑
    private void OnConfigurationChanged(UserProfileProviderOptions newOptions)
    {
        _logger.LogInformation("Configuration changed for {ComponentName}", nameof(UserProfileProvider));
        
        // 更新内部配置引用
        _options = newOptions;
        
        // 重新初始化依赖配置的资源（如数据库连接池）
        ReInitializeResources();
    }

    // 使用配置值的具体示例
    public async Task<UserProfile> GetUserProfileAsync(string userId)
    {
        // 直接使用配置属性值
        using var connection = new SqlConnection(_options.ConnectionString);
        using var command = new SqlCommand("SELECT * FROM UserProfiles WHERE UserId = @UserId", connection);
        
        // 设置命令超时时间
        command.CommandTimeout = (int)_options.CommandTimeout.TotalSeconds;
        command.Parameters.AddWithValue("@UserId", userId);

        try
        {
            await connection.OpenAsync();
            // 使用配置的重试机制
            return await ExecuteWithRetryAsync(command);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get user profile for {UserId}", userId);
            throw;
        }
    }

    // 使用配置值实现重试逻辑
    private async Task<UserProfile> ExecuteWithRetryAsync(SqlCommand command)
    {
        var retryCount = 0;
        while (retryCount < _options.MaxRetries)
        {
            try
            {
                // 执行查询
                using var reader = await command.ExecuteReaderAsync();
                return MapToUserProfile(reader);
            }
            catch (SqlException ex) when (retryCount < _options.MaxRetries - 1)
            {
                retryCount++;
                _logger.LogWarning("Database query failed, retry {RetryCount}/{MaxRetries} after {Delay}ms", 
                    retryCount, _options.MaxRetries, _options.RetryInterval.TotalMilliseconds);
                    
                await Task.Delay(_options.RetryInterval);
            }
        }
        
        throw new InvalidOperationException($"Failed after {_options.MaxRetries} retries");
    }

    // 健康检查中使用配置值
    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        if (!_options.IsEnabled)
            return HealthStatus.Degraded;

        try
        {
            using var connection = new SqlConnection(_options.ConnectionString);
            connection.ConnectionTimeout = (int)_options.CommandTimeout.TotalSeconds;
            await connection.OpenAsync(cancellationToken);
            return HealthStatus.Healthy;
        }
        catch
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

**步骤3：配置文件设置**
```json
{
  "DataProviders": {
    "UserProfile": {
      "ConnectionString": "Server=localhost;Database=AdSystem;Integrated Security=true;",
      "CommandTimeout": "00:00:30",        // 30秒超时
      "CacheExpiration": "01:00:00",       // 1小时缓存
      "IsEnabled": true,
      "MaxRetries": 3,
      "RetryInterval": "00:00:05"          // 5秒重试间隔
    }
  }
}
```

#### 2.2 简化的配置注入模式（一次性加载）

```csharp
// 对于不需要热重载的组件，可以使用 IOptions
public class SimpleCalculator : ICalculator
{
    private readonly CalculatorOptions _options;

    public SimpleCalculator(IOptions<CalculatorOptions> options)
    {
        _options = options.Value; // 一次性获取配置值，后续不会更新
    }

    public decimal CalculateBidPrice(BidRequest request)
    {
        // 直接使用配置属性
        var basePrice = _options.BasePriceCents;
        var multiplier = _options.PriceMultiplier;
        
        return basePrice * multiplier;
    }
}

public class CalculatorOptions
{
    public decimal BasePriceCents { get; set; } = 100;
    public decimal PriceMultiplier { get; set; } = 1.0m;
}
```

#### 2.3 配置验证和错误处理

```csharp
// 配置验证器示例
public class UserProfileProviderOptionsValidator : IValidateOptions<UserProfileProviderOptions>
{
    public ValidateOptionsResult Validate(string name, UserProfileProviderOptions options)
    {
        var failures = new List<string>();

        // 验证连接字符串
        if (string.IsNullOrWhiteSpace(options.ConnectionString))
            failures.Add("ConnectionString is required");

        // 验证超时时间
        if (options.CommandTimeout <= TimeSpan.Zero)
            failures.Add("CommandTimeout must be positive");

        // 验证重试配置
        if (options.MaxRetries < 0)
            failures.Add("MaxRetries cannot be negative");

        if (options.RetryInterval <= TimeSpan.Zero)
            failures.Add("RetryInterval must be positive");

        return failures.Any() 
            ? ValidateOptionsResult.Fail(failures)
            : ValidateOptionsResult.Success;
    }
}
```

#### 2.4 配置属性的数据类型约定

**时间相关配置**：
```csharp
public class ComponentOptions
{
    // .NET TimeSpan 格式："HH:mm:ss" 或 "d.HH:mm:ss"
    public TimeSpan Timeout { get; set; }           // "00:00:30" = 30秒
    public TimeSpan Interval { get; set; }          // "00:05:00" = 5分钟
    public TimeSpan CacheExpiry { get; set; }       // "24:00:00" = 24小时
}
```

**数值相关配置**：
```csharp
public class ComponentOptions
{
    public int MaxCount { get; set; }               // 整数
    public decimal PriceThreshold { get; set; }     // 金额
    public double ScoreWeight { get; set; }         // 权重分数 (0.0-1.0)
    public long MaxMemoryBytes { get; set; }        // 字节数
}
```

**字符串相关配置**：
```csharp
public class ComponentOptions
{
    public string ConnectionString { get; set; } = "";     // 连接字符串
    public string ApiEndpoint { get; set; } = "";          // URL地址
    public string LogLevel { get; set; } = "Information";  // 枚举字符串
}
```

**集合相关配置**：
```csharp
public class ComponentOptions
{
    public List<string> AllowedHosts { get; set; } = new();
    public Dictionary<string, string> Headers { get; set; } = new();
    public string[] Keywords { get; set; } = Array.Empty<string>();
}
```

**配置文件对应示例**：
```json
{
  "ComponentExample": {
    "Timeout": "00:00:30",
    "MaxCount": 1000,
    "PriceThreshold": 10.50,
    "ScoreWeight": 0.85,
    "ConnectionString": "Server=localhost;Database=Test;",
    "AllowedHosts": ["localhost", "example.com"],
    "Headers": {
      "User-Agent": "AdSystem/1.0",
      "Accept": "application/json"
    },
    "Keywords": ["advertising", "marketing", "campaign"]
  }
}
```

### 可配置接口约定

#### 1. IConfigurable 接口实现

**接口定义**：
```csharp
public interface IConfigurable
{
    /// <summary>
    /// 当配置发生变更时调用此方法重新配置组件
    /// </summary>
    /// <param name="configuration">新的配置对象</param>
    void Configure(object configuration);
    
    /// <summary>
    /// 获取组件的配置类型
    /// </summary>
    Type ConfigurationType { get; }
}
```

**使用场景**：
- 需要**自定义配置更新逻辑**的组件
- 需要在配置变更时**执行特殊初始化**的组件
- 需要**验证配置变更**是否安全的组件

#### 2. IConfigurable 接口实现示例

**基础实现模式**：
```csharp
public class AdvancedDataProvider : IDataAccessProvider, IConfigurable, IHealthCheckable
{
    private readonly ILogger<AdvancedDataProvider> _logger;
    private readonly IOptionsMonitor<AdvancedDataProviderOptions> _optionsMonitor;
    private AdvancedDataProviderOptions _options;
    private IDbConnection? _connection;

    public Type ConfigurationType => typeof(AdvancedDataProviderOptions);

    public AdvancedDataProvider(
        IOptionsMonitor<AdvancedDataProviderOptions> optionsMonitor,
        ILogger<AdvancedDataProvider> logger)
    {
        _optionsMonitor = optionsMonitor;
        _logger = logger;
        _options = optionsMonitor.CurrentValue;
        
        // 初始化配置
        Configure(_options);
        
        // 订阅配置变更
        _optionsMonitor.OnChange(newOptions => Configure(newOptions));
    }

    public void Configure(object configuration)
    {
        if (configuration is not AdvancedDataProviderOptions newOptions)
        {
            _logger.LogWarning("Invalid configuration type for {ComponentName}", nameof(AdvancedDataProvider));
            return;
        }

        var oldOptions = _options;
        _options = newOptions;

        try
        {
            // 检查关键配置是否变更
            if (oldOptions?.ConnectionString != newOptions.ConnectionString)
            {
                _logger.LogInformation("Connection string changed, reinitializing connection pool");
                ReinitializeConnection();
            }

            // 检查其他配置变更
            if (oldOptions?.CommandTimeout != newOptions.CommandTimeout)
            {
                _logger.LogInformation("Command timeout changed from {OldTimeout} to {NewTimeout}",
                    oldOptions?.CommandTimeout, newOptions.CommandTimeout);
            }

            // 验证新配置的有效性
            ValidateConfiguration(newOptions);
            
            _logger.LogInformation("Configuration updated successfully for {ComponentName}", 
                nameof(AdvancedDataProvider));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to apply new configuration, reverting to previous configuration");
            _options = oldOptions; // 回滚到旧配置
            throw;
        }
    }

    private void ReinitializeConnection()
    {
        // 关闭旧连接
        _connection?.Dispose();
        
        // 创建新连接
        _connection = new SqlConnection(_options.ConnectionString);
        
        // 测试新连接
        _connection.Open();
        _connection.Close();
    }

    private void ValidateConfiguration(AdvancedDataProviderOptions options)
    {
        if (string.IsNullOrWhiteSpace(options.ConnectionString))
            throw new InvalidOperationException("ConnectionString cannot be empty");

        if (options.CommandTimeout <= TimeSpan.Zero)
            throw new InvalidOperationException("CommandTimeout must be positive");

        // 测试连接字符串有效性
        try
        {
            using var testConnection = new SqlConnection(options.ConnectionString);
            testConnection.Open();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException($"Invalid connection string: {ex.Message}", ex);
        }
    }

    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            if (!_options.IsEnabled)
                return HealthStatus.Degraded;

            using var connection = new SqlConnection(_options.ConnectionString);
            await connection.OpenAsync(cancellationToken);
            return HealthStatus.Healthy;
        }
        catch
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

#### 3. IConfigurable vs IOptionsMonitor 选择指南

**使用 IOptionsMonitor（推荐）**：
- 简单的配置绑定需求
- 只需要获取配置值，无特殊逻辑
- 标准的配置更新处理

```csharp
// 简单场景：只需要读取配置值
public SimpleService(IOptionsMonitor<SimpleOptions> options)
{
    _options = options.CurrentValue;
    options.OnChange(newOptions => _options = newOptions);
}
```

**使用 IConfigurable（高级场景）**：
- 需要自定义配置更新逻辑
- 配置变更时需要重新初始化资源
- 需要验证配置变更的安全性
- 需要在配置错误时回滚到旧配置

```csharp
// 复杂场景：需要自定义配置处理逻辑
public ComplexService : IConfigurable
{
    public void Configure(object configuration)
    {
        // 自定义配置更新逻辑
        // 资源重新初始化
        // 配置验证
        // 错误处理和回滚
    }
}
```

#### 4. 配置更新最佳实践

**配置更新安全原则**：
1. **先验证后应用**：新配置必须通过验证才能应用
2. **原子更新**：配置更新要么全部成功，要么全部失败
3. **优雅降级**：配置错误时应保持服务可用性
4. **日志记录**：详细记录配置变更过程和结果

**线程安全考虑**：
```csharp
public class ThreadSafeConfigurableService : IConfigurable
{
    private readonly object _configLock = new object();
    private ServiceOptions _options;

    public void Configure(object configuration)
    {
        if (configuration is not ServiceOptions newOptions)
            return;

        lock (_configLock)
        {
            var oldOptions = _options;
            try
            {
                // 验证新配置
                ValidateConfiguration(newOptions);
                
                // 应用新配置
                _options = newOptions;
                
                // 重新初始化资源
                ReinitializeResources();
            }
            catch
            {
                // 回滚到旧配置
                _options = oldOptions;
                throw;
            }
        }
    }
}
```

### 健康检查约定

#### 1. 健康检查接口实现

**必须实现的接口**：
```csharp
public interface IHealthCheckable
{
    Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default);
}
```

**健康状态定义**：
- `HealthStatus.Healthy`：组件正常工作
- `HealthStatus.Degraded`：组件部分功能受限但仍可用
- `HealthStatus.Unhealthy`：组件不可用

**实现示例**：
```csharp
public class UserInterestRecallStrategy : IAdProcessingStrategy, IHealthCheckable
{
    public async Task<HealthStatus> CheckHealthAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            // 检查依赖服务
            if (!await _dataProvider.IsAvailableAsync(cancellationToken))
                return HealthStatus.Degraded;
                
            // 检查配置有效性
            if (_options.MaxCandidates <= 0)
                return HealthStatus.Unhealthy;
                
            return HealthStatus.Healthy;
        }
        catch (Exception)
        {
            return HealthStatus.Unhealthy;
        }
    }
}
```

### 验证约定

#### 1. 配置验证规范

**数据注解验证**：
```csharp
public class UserInterestRecallOptions
{
    [Range(1, 10000)]
    public int MaxCandidates { get; set; } = 1000;
    
    [Required]
    public TimeSpan CacheExpiration { get; set; } = TimeSpan.FromMinutes(15);
    
    [Range(0.0, 1.0)]
    public double ScoreThreshold { get; set; } = 0.3;
}
```

**自定义验证器**：
```csharp
public class UserInterestRecallOptionsValidator : IValidateOptions<UserInterestRecallOptions>
{
    public ValidateOptionsResult Validate(string name, UserInterestRecallOptions options)
    {
        var failures = new List<string>();
        
        if (options.MaxCandidates <= 0)
            failures.Add("MaxCandidates must be greater than 0");
            
        if (options.CacheExpiration <= TimeSpan.Zero)
            failures.Add("CacheExpiration must be positive");
            
        if (options.ScoreThreshold < 0 || options.ScoreThreshold > 1)
            failures.Add("ScoreThreshold must be between 0 and 1");
            
        return failures.Any() 
            ? ValidateOptionsResult.Fail(failures)
            : ValidateOptionsResult.Success;
    }
}
```

### 特性标记约定

#### 1. 组件标记特性

**基础组件特性**：
```csharp
[Component(Priority = 100, IsEnabled = true)]
public class MyStrategy : IAdProcessingStrategy { }
```

**生命周期特性**：
```csharp
[Singleton] // 强制单例
[Scoped]    // 强制作用域
[Transient] // 强制瞬态（默认）
```

**配置绑定特性**：
```csharp
[ConfigurationBinding("CustomPath:Section")]
public class CustomComponent { }
```

**条件注册特性**：
```csharp
[ConditionalOnProperty("FeatureFlags:EnableAdvancedTargeting", Value = "true")]
public class AdvancedTargetingStrategy : IAdProcessingStrategy { }
```

#### 2. 特性使用优先级

1. **显式特性标记**（最高优先级）
2. **接口约定**（中等优先级）
3. **命名约定**（最低优先级）

### 错误处理约定

#### 1. 异常处理规范

**组件内异常处理**：
```csharp
public async Task<ProcessingResult> ProcessAsync(AdRequest request, ProcessingContext context)
{
    try
    {
        // 业务逻辑
        return new ProcessingResult { Success = true };
    }
    catch (ConfigurationException ex)
    {
        _logger.LogError(ex, "Configuration error in {ComponentName}", GetType().Name);
        return new ProcessingResult { Success = false, Error = ex.Message };
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Unexpected error in {ComponentName}", GetType().Name);
        return new ProcessingResult { Success = false, Error = "Internal error" };
    }
}
```

**配置错误处理**：
- 配置验证失败时应用启动失败（快速失败原则）
- 运行时配置错误应优雅降级，不影响整体系统

**依赖错误处理**：
- 可选依赖缺失时应优雅降级
- 必需依赖缺失时应启动失败

### 日志约定

#### 1. 日志记录规范

**日志级别使用**：
- `LogCritical`：系统无法继续运行
- `LogError`：组件执行失败但系统可继续
- `LogWarning`：潜在问题或降级运行
- `LogInformation`：重要业务事件
- `LogDebug`：详细调试信息

**日志消息格式**：
```csharp
_logger.LogInformation("Processing ad request {RequestId} with {CandidateCount} candidates", 
    request.Id, candidates.Count());

_logger.LogWarning("Strategy {StrategyName} execution took {Duration}ms, exceeding threshold", 
    GetType().Name, duration.TotalMilliseconds);

_logger.LogError(ex, "Failed to process request {RequestId} in {ComponentName}", 
    request.Id, GetType().Name);
```

这些约定规范确保了：
1. **一致性**：所有组件遵循相同的命名和结构约定
2. **可预测性**：基础设施能够准确推断组件行为
3. **可维护性**：标准化的模式降低学习成本
4. **可扩展性**：新组件无需修改基础设施代码

## 约定规范速查表

### 组件开发者速查

#### 组件命名速查表

| 组件用途   | 命名格式                     | 实现接口                | 生命周期  | 配置路径示例                    |
| ---------- | ---------------------------- | ----------------------- | --------- | ------------------------------- |
| 广告策略   | `{功能}Strategy`             | `IAdProcessingStrategy` | Transient | `Strategies:UserInterestRecall` |
| 数据提供者 | `{数据源}Provider`           | `IDataAccessProvider`   | Scoped    | `DataProviders:RedisUser`       |
| 业务服务   | `{功能}Service`              | 自定义接口              | Singleton | `Services:MetricsCollection`    |
| 管理器     | `{功能}Manager`              | 自定义接口              | Singleton | `CampaignManager`               |
| 回调提供者 | `{回调类型}CallbackProvider` | `ICallbackProvider`     | Singleton | `Callbacks:AdEngine`            |
| 定向匹配器 | `{类型}Matcher`              | `ITargetingMatcher`     | Transient | `Targeting:Geographic`          |
| 计算器     | `{内容}Calculator`           | 自定义接口              | Transient | `BidPriceCalculator`            |
| 处理器     | `{内容}Processor`            | 自定义接口              | Transient | `AdRequestProcessor`            |

#### 配置开发者速查表

| 配置类型   | 命名格式            | 映射配置节                 | 必须属性                        | 可选接口             |
| ---------- | ------------------- | -------------------------- | ------------------------------- | -------------------- |
| 策略配置   | `{策略名}Options`   | `Strategies:{策略名}`      | `IsEnabled`, `Priority`         | `IValidatableObject` |
| 服务配置   | `{服务名}Options`   | `Services:{服务名}`        | `IsEnabled`                     | `IValidatableObject` |
| 核心配置   | `{模块名}Options`   | `{模块名}`                 | 根据需要                        | `IValidatableObject` |
| 提供者配置 | `{提供者名}Options` | `DataProviders:{提供者名}` | `IsEnabled`, `ConnectionString` | `IValidatableObject` |

#### 配置文件结构速查

```json
{
  // 核心系统配置
  "AdEngine": { "MaxConcurrentRequests": 1000 },
  "DataAccess": { "DefaultConnectionString": "..." },
  "Monitoring": { "HealthChecks": { "Enabled": true } },
  "Security": { "Authentication": { "RequireApiKey": true } },
  "Performance": { "Caching": { "DefaultExpiration": "00:15:00" } },
  
  // 业务组件配置
  "Strategies": {
    "{StrategyName}": { "IsEnabled": true, "Priority": 100 }
  },
  "DataProviders": {
    "{ProviderName}": { "IsEnabled": true, "ConnectionString": "..." }
  },
  "Targeting": {
    "{TargetingType}": { "MaxDistanceKm": 50 }
  },
  "CallbackProviders": {
    "{回调类型}": { "IsEnabled": true, "TimeoutMs": 5000 }
  },
  "Bidding": {
    "RTB": { "TimeoutMs": 100 }
  },
  "Creative": {
    "Validation": { "MaxFileSizeMB": 10 }
  }
}
```

### 开发流程速查

#### 添加新策略组件

1. **创建策略类**：
   ```csharp
   public class NewFeatureStrategy : IAdProcessingStrategy, IHealthCheckable
   ```

2. **创建配置类**：
   ```csharp
   public class NewFeatureOptions : IValidatableObject
   ```

3. **添加配置节**：
   ```json
   "Strategies": { "NewFeature": { "IsEnabled": true, "Priority": 100 } }
   ```

4. **验证组件**：启动应用，检查日志确认组件已注册

#### 添加新数据提供者

1. **创建提供者类**：
   ```csharp
   public class NewDataProvider : IDataAccessProvider, IHealthCheckable
   ```

2. **创建配置类**：
   ```csharp
   public class NewDataOptions
   ```

3. **添加配置节**：
   ```json
   "DataProviders": { "NewData": { "IsEnabled": true, "ConnectionString": "..." } }
   ```

#### 添加新回调提供者

1. **创建提供者类**：
   ```csharp
   public class BiddingCallbackProvider : ICallbackProvider, IHealthCheckable
   ```

2. **创建配置类**：
   ```csharp
   public class BiddingCallbackOptions
   ```

3. **添加配置节**：
   ```json
   "CallbackProviders": { "Bidding": { "IsEnabled": true, "TimeoutMs": 5000 } }
   ```

4. **使用回调接口**：通过依赖注入获取类型安全的回调接口访问

#### 修改配置

1. **编辑配置文件**：直接修改 `appsettings.json`
2. **热重载生效**：无需重启应用
3. **验证生效**：检查健康检查状态

### 故障排除速查

#### 组件未被发现

- ✅ 检查命名约定是否正确
- ✅ 确认实现了正确的接口
- ✅ 验证程序集是否被扫描

#### 配置绑定失败

- ✅ 检查配置类命名：`{模块}Options`
- ✅ 确认配置节路径正确
- ✅ 验证配置文件格式有效

#### 健康检查失败

- ✅ 检查 `IHealthCheckable` 实现
- ✅ 确认依赖服务可用
- ✅ 验证配置值有效性

#### 依赖注入失败

- ✅ 检查构造函数参数类型
- ✅ 确认依赖已注册
- ✅ 验证生命周期匹配

这些约定规范确保了基础设施的自动化程度，让开发者可以专注于业务逻辑实现，而无需关心底层的配置管理和依赖注入细节。
